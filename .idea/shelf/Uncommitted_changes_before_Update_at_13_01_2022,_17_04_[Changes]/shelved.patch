Index: extract_from_binary.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport os\nimport sys\nimport pandas as pd\nimport pickle\nimport json as jsn\nfrom datetime import datetime\nfrom pathlib import Path\nfrom Supporting_func import Fig_plot as fp, align_spectrum, path_to_data\n# from Supporting_func import align_spectrum, path_to_data\nfrom Interface import main\nfrom Interface.window_handler import exec_app\n\ncurrent_dir = Path.cwd()\nhome_dir = Path.home()\n\nsys.path.insert(0, Path(current_dir, 'Supporting_func'))\nsys.path.insert(0, Path(current_dir, 'Interface'))\nstart = datetime.now()\n\nparameters = main()\ncurrent_data_file = parameters['file_name']      # Имя файла с исходными текущими данными без расширения\ncurrent_data_dir = parameters['file_folder']          # Папка с текущими данными\n\nalign_file_name = 'Align_coeff.bin'         # Имя файла с текущими коэффициентами выравнивания АЧХ\ncurrent_catalog = r'2021/Results'           # Текущий каталог (за определенный период, здесь - год)\n\nfile_path_data, head_path = path_to_data(current_catalog, current_data_dir)\nfolder_align_path = Path(head_path, 'Alignment')\ndate = current_data_file[0:11]\n\n# !!!! ******************************************* !!!!\n# ****** Блок исходных параметров для обработки *******\n\n\nfreq_res = parameters['freq_res']  # Установка разрешения по частоте в МГц\nkt = parameters['time_res'] // 8  # Установка разрешения по времени в единицах минимального разрешения 8.1925e-3 сек\n\nN_Nyq = 2   # Номер зоны Найквиста\nshift = 10  # Усечение младших разрядов при обработке первичного бинарного файла данных\n# *****************************************************\n\ndelta_t = 8.1925e-3\ndelta_f = 7.8125\nnum_of_polar = 2  # Параметр равен \"1\" для записей до 12.12.2020 и \"2\" для записей после 12.12.2020\nif num_of_polar == 1:\n    q = int(current_data_file[-1])\n    N_Nyq = q\nband_size_init = 'whole'\n# band_size = 'whole'   Параметр 'whole' означает работу в диапазоне 1-3 ГГц, 'half' - диапазон 1-2 или 2-3 ГГц\n# polar = 'both'        Принимает значения поляризаций: 'both', 'left', 'right'\nrobust_filter = 'n'\nparam_robust_filter = 1.1\nalign = 'y'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ ('y' / 'n')\n\nnoise_calibr = 'n'\ngraph_3d_perm = 'n'\ncontour_2d_perm = 'n'\n\nif N_Nyq == 3:\n    freq_spect_mask = [2120, 2300, 2700, 2820, 2900]  # 2060, 2750, 2760, 2770, 2780, 2790, 2800, 2810,\n    # 2820, 2830, 2850, 2880, 2900, 2950# Временные сканы Солнца на этих частотах\nelif band_size_init == 'whole':\n    n1 = 2\n    n2 = 9\n    freq_spect_mask = parameters['freq_mask']\n    # freq_spect_mask = [2060, 2220, 2300, 2500, 2560, 2700, 2800, 2880, 2980]\n    # freq_spect_mask = [1080, 1140, 1360, 1420, 1620, 1780, 1980]\n    # freq_spect_mask = [1535,  2450, 2550, 2750,  2800, 2950]\n    # freq_spect_mask = [1000 * n1 + 100 * n2 + 10 * i for i in range(10)]\n    # freq_spect_mask = [1050, 1465, 1500, 1535, 1600, 1700, 1750, 1950]\n    # freq_spect_mask = [1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920]\n    # freq_spect_mask = [1140, 1420, 1480, 2460, 2500, 2780] # for Crab '2021-06-28_03+14'\n    # freq_spect_mask = [1220, 1540, 1980, 2060, 2500, 2780] # for Crab '2021-06-28_04+12'\nelse:\n    freq_spect_mask = [1171, 1380, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920]\n\ntime_spect_mask = [47, 84.4, 104, 133, 133.05, 177.02, 177.38]  # Срез частотного спектра в эти моменты времени\n\natt_val = [i * 0.5 for i in range(64)]\natt_dict = {s: 10 ** (s / 10) for s in att_val}\npass\n\n\ndef extract():\n    file_name = Path(file_path_data, current_data_file + '.bin')\n    file_name_out = Path(file_path_data, current_data_file + '.txt')\n    i = 0\n    k = 0\n    spectr = []\n    frame = ' '\n\n    try:\n        if os.path.isfile(file_name) == 1:\n            pass\n        else:\n            print('\\n \\t', file_name, ' not found!!!\\n')\n\n        f_in = open(file_name, 'rb')\n\n        while frame:\n\n            spectr_frame = []\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\n            for k in range(129):\n                frame = f_in.read(8)\n                frame_int = int.from_bytes(frame, byteorder='little')\n                if k == 0:\n                    frame_num = frame_int & 0xFFFFFFF\n\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\n                    if i == 0:\n                        n_aver = (frame_int & 0x3F00000000) >> 32\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\n                    spectr_frame.append(frame_num)\n\n                else:\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\n                    spectr_frame.append(spectr_val)\n                    pass\n\n            spectr.append(spectr_frame)\n            print(i, frame_num)\n            i += 1\n\n        pass\n\n        spectr.pop(-1)\n        N = len(spectr)\n        n_frame_last = spectr[-1][0]\n        rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\n        if rest:\n            for k in range(rest):\n                spectr.pop(-1)\n        print(n_frame_last, spectr[-1][0])\n    finally:\n        f_in.close()\n        pass\n\n        spectr1 = convert_to_matrix(spectr, spectr[-1][0] + 1, n_aver)\n    np.savetxt(file_name_out, spectr1, header=(str(n_aver) + '-n_aver ' + str(bound_left) + '-kurt'))\n\n    return spectr1, n_aver\n\n\ndef extract_two_polar():\n    file_name = file_name0 + '.bin'\n    # file_name_out = file_name0 + '.txt'\n    # *********** Если система работает с одной поляризацией ************\n    if not file_name0.find('Ant2') == -1:\n        antenna2_0 = 1\n    else:\n        antenna2_0 = 0\n    # *******************************************************************\n    i = 0\n    k = 0\n    spectr_left = []\n    spectr_right = []\n    attenuators = []\n    frame = ' '\n\n    try:\n        if os.path.isfile(file_name) == 1:\n            pass\n        else:\n            print('\\n \\t', file_name, ' not found!!!\\n')\n\n        f_in = open(file_name, 'rb')\n        antenna = 0\n        while frame:\n\n            spectr_frame = []\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\n            for k in range(130):\n                frame = f_in.read(8)\n                frame_int = int.from_bytes(frame, byteorder='little')\n                if k == 0:\n                    frame_num = frame_int & 0xFFFFFFF\n\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\n                    if i == 0:\n                        n_aver = (frame_int & 0x3F00000000) >> 32\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\n                    spectr_frame.append(frame_num)\n                elif k == 1:\n                    att_1 = frame_int & 0x3F\n                    att_2 = (frame_int & 0xFC0) >> 6\n                    att_3 = (frame_int & 0x3F000) >> 12\n                    noise_gen_on = (frame_int & 0x40000) >> 18\n                    antenna_before = antenna\n                    antenna = (frame_int & 0x80000) >> 19\n                    coupler = (frame_int & 0x100000) >> 20\n                    band = (frame_int & 0x8000000000000000) >> 63\n                    attenuators = [att_1, att_2, att_3]\n\n                    pass\n\n                else:\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\n                    if pp_good / 256 < 0.78125:\n                        spectr_val = 2\n                    spectr_frame.append(spectr_val)\n                    pass\n\n            if antenna == 0 and (antenna_before - antenna == 0):\n                spectr_left.append(spectr_frame)\n            elif len(spectr_left) > 1 and ((antenna_before - antenna) != 0):\n                spectr_left.pop(-1)\n\n            if antenna == 1 and (antenna_before - antenna) == 0:\n                spectr_right.append(spectr_frame)\n            elif len(spectr_right) > 1 and ((antenna_before - antenna) != 0):\n                spectr_right.pop(-1)\n            print(i, frame_num, band)\n            i += 1\n\n        pass\n        n_right = len(spectr_right)\n        n_left = len(spectr_left)\n\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\n        # то необходима следующая процедура перестановки значений переменных\n        if n_right == 0 and antenna2_0 == 1:\n            spectr_right = spectr_left\n            spectr_left = []\n            n_right = len(spectr_right)\n            n_left = len(spectr_left)\n        # **********************************************************************************\n        if n_right > 1:\n            spectr_right.pop(-1)\n            n_frame_last = spectr_right[-1][0]\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\n            if rest:\n                for k in range(rest):\n                    spectr_right.pop(-1)\n            print(n_frame_last, spectr_right[-1][0])\n        if n_left > 1:\n            spectr_left.pop(-1)\n            n_frame_last = spectr_left[-1][0]\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\n            if rest:\n                for k in range(rest):\n                    spectr_left.pop(-1)\n            print(n_frame_last, spectr_left[-1][0])\n    finally:\n        f_in.close()\n        pass\n\n    if n_left > 1:\n        spectr1 = convert_to_matrix(spectr_left, spectr_left[-1][0] + 1, n_aver)\n    else:\n        spectr1 = []\n    if n_right > 1:\n        spectr2 = convert_to_matrix(spectr_right, spectr_right[-1][0] + 1, n_aver)\n    else:\n        spectr2 = []\n    spectrum_extr = pd.Series([spectr1, spectr2])\n    np.save(file_name0 + '_spectrum', spectrum_extr)\n    head = np.array([n_aver, 6, 8])\n    np.savetxt(file_name0 + '_head.txt', head)\n    return spectrum_extr, n_aver\n\n\ndef extract_whole_band():\n    file_name = Path(file_path_data, current_data_file + '.bin')\n    # *********** Если система работает с одной поляризацией ************\n    if not str(file_name).find('Ant2') == -1:\n        antenna2_0 = 1\n    else:\n        antenna2_0 = 0\n    # *******************************************************************\n    i = 0\n    spectrum_right_1 = []\n    spectrum_left_1 = []\n    spectrum_left_2 = []\n    spectrum_right_2 = []\n    attenuators = []\n    frame = ' '\n\n    try:\n        if os.path.isfile(file_name) == 1:\n            pass\n        else:\n            print('\\n \\t', file_name, ' not found!!!\\n')\n            return\n\n        f_in = open(file_name, 'rb')\n        antenna = 0\n        while frame:\n            spectr_frame = []\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\n            # и 128-ми значений спектра в список spectr_frame на позиции [2:129]\n            for k in range(130):\n                frame = f_in.read(8)\n                frame_int = int.from_bytes(frame, byteorder='little')\n                if k == 0:\n                    frame_num = frame_int & 0xFFFFFFF\n\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\n                    if i == 0:\n                        n_aver = (frame_int & 0x3F00000000) >> 32\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\n                    spectr_frame.append(frame_num)\n                elif k == 1:\n                    att_1 = frame_int & 0x3F\n                    att_1 = int((63 - att_1) / 2)\n                    att_2 = (frame_int & 0xFC0) >> 6\n                    att_2 = int((63 - att_2) / 2)\n                    att_3 = (frame_int & 0x3F000) >> 12\n                    att_3 = int((63 - att_3) / 2)\n                    noise_gen_on = (frame_int & 0x40000) >> 18\n                    antenna_before = antenna\n                    antenna = (frame_int & 0x80000) >> 19\n                    if antenna == 1:\n                        pass\n                    coupler = (frame_int & 0x100000) >> 20\n                    band = (frame_int & 0x8000000000000000) >> 63\n                    attenuators = [att_1, att_2, att_3]\n                    if i == 10:\n                        att01 = att_1\n                        att02 = att_2\n                        att03 = att_3\n                    pass\n\n                else:\n                    spectrum_val = (frame_int & 0x7FFFFFFFFFFFFF) >> shift\n\n                    # Отбросили \"shift\" младших разрядов двоичного представления или 3 разряда десятичного\n                    # при \"shift=10\"\n                    if band:\n                        spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_1]))\n                    else:\n                        spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_2]))\n                    # if spectrum_val > 1000000000:\n                    #     spectrum_val = 1000000000\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\n                    if pp_good / 256 < 0.1:\n                        spectrum_val = 2\n                    spectr_frame.append(spectrum_val)\n                    pass\n\n            if antenna == 0 and (antenna_before - antenna == 0):\n                if band:\n                    spectrum_left_2.append(spectr_frame)\n                else:\n                    spectrum_left_1.append(spectr_frame)\n            if len(spectrum_left_1) > 1 and ((antenna_before - antenna) != 0):\n                spectrum_left_1.pop(-1)\n            if len(spectrum_left_2) > 1 and ((antenna_before - antenna) != 0):\n                spectrum_left_2.pop(-1)\n\n            if antenna == 1 and (antenna_before - antenna) == 0:\n                if band:\n                    spectrum_right_2.append(spectr_frame)\n                else:\n                    spectrum_right_1.append(spectr_frame)\n            if len(spectrum_right_1) > 1 and ((antenna_before - antenna) != 0):\n                spectrum_right_1.pop(-1)\n            if len(spectrum_right_2) > 1 and ((antenna_before - antenna) != 0):\n                spectrum_right_2.pop(-1)\n\n            print(i, frame_num, band, attenuators)\n            i += 1\n            if att_1 == 31 & att_2 == 31 & att_3 == 31:\n                break\n        pass\n        n_right1 = len(spectrum_right_1)\n        n_left1 = len(spectrum_left_1)\n        n_right2 = len(spectrum_right_2)\n        n_left2 = len(spectrum_left_2)\n\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\n        # то необходима следующая процедура перестановки значений переменных\n        n_right = np.max([len(spectrum_right_1), len(spectrum_right_2)])\n        if n_right == 0 and antenna2_0 == 1:\n            spectrum_right_1 = spectrum_left_1\n            spectrum_left_1 = []\n            spectrum_right_2 = spectrum_left_2\n            spectrum_left_2 = []\n            n_right1 = len(spectrum_right_1)\n            n_left1 = len(spectrum_left_1)\n            n_right2 = len(spectrum_right_2)\n            n_left2 = len(spectrum_left_2)\n\n        # Приведение длины записи к величине кратной количеству частот\n        if n_right1 > 1:\n            spectrum_right_1 = cut_spectrum(spectrum_right_1, n_aver)\n            # spectrum_right_1 = np.array(spectrum_right_1, dtype=np.int32)\n            spectrum_right_1 = parts_to_numpy(spectrum_right_1, n_right1)\n        if n_left1 > 1:\n            spectrum_left_1 = cut_spectrum(spectrum_left_1, n_aver)\n            spectrum_left_1 = np.array(spectrum_left_1, dtype=np.int64)\n        if n_right2 > 1:\n            spectrum_right_2 = cut_spectrum(spectrum_right_2, n_aver)\n            # spectrum_right_2 = np.array(spectrum_right_2, dtype=np.int32)\n            spectrum_right_2 = parts_to_numpy(spectrum_right_2, n_right2)\n        if n_left2 > 1:\n            spectrum_left_2 = cut_spectrum(spectrum_left_2, n_aver)\n            spectrum_left_2 = np.array(spectrum_left_2, dtype=np.int64)\n    finally:\n        f_in.close()\n        pass\n    spectrum_extr = pd.Series([spectrum_left_1, spectrum_left_2, spectrum_right_1, spectrum_right_2])\n    # head = [n_aver, shift, bound_left, bound_right, att01, att02, att03]\n    band_size, polar, measure_kind = status_func(n_left1, n_left2, n_right1, n_right2)\n\n    head = {'date': date,\n            'measure_kind': measure_kind,    # Вид измерений: наблюдение Солнца, Луны, калибровка АЧХ\n            'band_size': band_size,  # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\n            # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\n            'polar': polar,  # Принимает значения поляризаций: 'both', 'left', 'right'\n            'cleaned': 'no',\n            'n_aver': n_aver,\n            'shift': shift,\n            'kurtosis': bound_left,\n            'att1': att01,\n            'att2': att02,\n            'att3': att03,\n            'align_file_path': r'F:\\Fast_Acquisition\\Alignment\\Align_coeff.bin',\n            'align_coeff_pos': 5}\n    return save_spectrum(spectrum_extr, head)\n\n\ndef parts_to_numpy(list_arr, len_list):\n    \"\"\" Функция превращает список в массив numpy.\n    Разбивает файл на меньшие части и обрабатывает их поотдельности. По ходу завершинея обработки частей\n    происходит объединение обработанных частей.\"\"\"\n    n = int(len_list // 1e5)\n    k = int(len_list % 1e5)\n    numpy_arr = []\n    for i in range(n + 1):\n        if i == n:\n            auxiliary = list_arr[int(i * 1e5):int(i * 1e5 + k)]\n            auxiliary = np.array(auxiliary, dtype='int64')\n        else:\n            auxiliary = list_arr[int(i * 1e5):int((i + 1) * 1e5)]\n            auxiliary = np.array(auxiliary, dtype='int64')\n        l = np.size(numpy_arr)\n        if l:\n            numpy_arr = np.vstack([numpy_arr, auxiliary])\n        else:\n            numpy_arr = auxiliary\n\n    return numpy_arr\n\n\ndef status_func(n_left1, n_left2, n_right1, n_right2):\n\n    # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\n    # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\n    if (n_left1 > 1 and n_left2 > 1) or (n_right1 > 1 and n_right2 > 1):\n        band_size = 'whole'\n    if (n_left1 > 1 or n_right1 > 1) and (n_left2 <= 1 and n_right2 <= 1):\n        band_size = 'half_low'\n    if (n_left2 > 1 or n_right2 > 1) and (n_left1 <= 1 and n_right1 <= 1):\n        band_size = 'half_upper'\n\n    # polar Принамает значения поляризаций: 'both', 'left', 'right'\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 <= 1 or n_right2 <= 1):\n        polar = 'left'\n    if (n_left1 <= 1 or n_left2 <= 1) and (n_right1 > 1 or n_right2 > 1):\n        polar = 'right'\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 > 1 or n_right2 > 1):\n        polar = 'both'\n\n    # Определение вида измерений: наблюдение Солнца, Луны, калибровка АЧХ\n    measure_kind = ''\n    file_name0 = str(Path(file_path_data, current_data_file))\n    if file_name0.find('test') != -1:\n        # l = file_name0.find('test')\n        measure_kind = 'test'\n    if file_name0.find('sun') != -1:\n        measure_kind = 'Sun'\n    if file_name0.find('moon') != -1:\n        measure_kind = 'Moon'\n    if file_name0.find('calibration') != -1:\n        measure_kind = 'calibration'\n\n    return band_size, polar, measure_kind\n\n\ndef save_spectrum(spectrum_extr, head):\n    spectrum1 = spectrum_extr[0]\n    spectrum2 = spectrum_extr[1]\n    spectrum3 = spectrum_extr[2]\n    spectrum4 = spectrum_extr[3]\n    n_aver = head['n_aver']\n    band_size = head['band_size']\n    polar = head['polar']\n    measure_kind = head['measure_kind']\n    print(f'len_spectrum1 = {len(spectrum1)}, len_spectrum2 ={len(spectrum2)}, len_spectrum3 ={len(spectrum3)}, '\n          f'len_spectrum4 ={len(spectrum4)}')\n    if len(spectrum1) > 1:\n        spectrum1_low = convert_to_matrix(spectrum1, spectrum1[-1][0] + 1, n_aver)\n        pass\n    else:\n        spectrum1_low = []\n    if len(spectrum2) > 1:\n        spectrum1_high = convert_to_matrix(spectrum2, spectrum2[-1][0] + 1, n_aver)\n    else:\n        spectrum1_high = []\n    if len(spectrum3) > 1:\n        spectrum2_low = convert_to_matrix(spectrum3, spectrum3[-1][0] + 1, n_aver)\n    else:\n        spectrum2_low = []\n    if len(spectrum4) > 1:\n        spectrum2_high = convert_to_matrix(spectrum4, spectrum4[-1][0] + 1, n_aver)\n    else:\n        spectrum2_high = []\n    spectrum_whole = pd.Series([spectrum1_low, spectrum1_high, spectrum2_low, spectrum2_high])\n    np.save(Path(file_path_data, current_data_file + '_spectrum'), spectrum_whole)\n    with open(Path(file_path_data, current_data_file + '_head.bin'), 'wb') as out:\n        pickle.dump(head, out)\n    jsn.dump(head, open(Path(file_path_data, current_data_file + '_head.txt'), \"w\"))\n    # np.savetxt(file_name0 + '_head.bin', head)\n\n    return spectrum_whole, n_aver, measure_kind, band_size, polar\n\n\ndef cut_spectrum(spectrum, n_aver):\n    spectrum.pop(-1)\n    n_frame_last = spectrum[-1][0]\n    rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\n    if rest:\n        for k in range(rest):\n            spectrum.pop(-1)\n    print(n_frame_last, spectrum[-1][0])\n    return spectrum\n\n\ndef convert_to_matrix(S_total, counter, n_aver):\n    \"\"\"Функция принимает список списков S, который формируется в extract(file_name0) и превращает его в матрицу,\n    строки которой - спектры с разрешением 7.8125/(2**(6-n_aver)) МГц, а столбцы - зависимость значения\n    спектра на фиксированной частоте от времени. Разрешение по времени - 8192 мкс. Вместо пропущенных пакетов\n    вставляет значение 2\"\"\"\n    len_time = np.shape(S_total)[0]\n    S = [[int(2)] * 128 for i in range(counter)]\n    # S = [['NaN'] * 128 for i in range(counter)]\n    for s in S_total:\n        S[s[0]] = s[1:]\n    aver_param_loc = 2 ** (6 - n_aver)\n    n = 128 * aver_param_loc\n    print(len(S))\n    k = int(len(S) // n)\n    print(f' n = {n}, k = {k}')\n    parts = int(k // 100)\n    rest = int(k % 100)\n    s_agreed = []\n\n    for i in range(parts +1):\n        if i == parts:\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i * 100 + rest) * n)])\n            s_ar = np.reshape(s_auxiliary, (-1, n))\n        else:\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i + 1) * 100 * n)])\n            s_ar = np.reshape(s_auxiliary, (-1, n))\n        l = np.size(s_agreed)\n        if l:\n            s_agreed = np.vstack([s_agreed, s_ar])\n        else:\n            s_agreed = s_ar\n\n    # s_agreed = np.array(S[0: k * n])\n    print(f'len_s_agreed = {len(s_agreed)}, shape = {np.shape(s_agreed)}')\n    # s_ar = np.reshape(s_agreed, (-1, n))\n    return s_agreed\n\n\ndef line_legend(freq_mask):\n    N_col_leg = len(freq_mask)\n    N_row_leg = len(time_spect_mask)\n    legend_freq = [0] * N_col_leg\n    legend_time = [0] * N_row_leg\n    i1 = 0\n    for i in freq_mask:\n        legend_freq[i1] = str(i) + ' MHz'\n        i1 += 1\n    i1 = 0\n    for i in time_spect_mask:\n        legend_time[i1] = str(i) + ' sec'\n        i1 += 1\n\n    return legend_time, legend_freq\n\n\ndef form_spectr_sp1(spectr_extr, freq_spect_mask_in=freq_spect_mask, time_spect_mask_in=time_spect_mask):\n    \"\"\" Возвращает s_freq - срезы частотного спектра в моменты времени time_spect_mask и s_time - сканы Солнца\n    по времени на частотах freq_spect_mask с заданным разрешением по времени и частоте\n\n    \"\"\"\n    ind_spec = []\n    ind_time = []\n    t_ng = 6000\n    N_col = np.shape(spectr_extr)[1]\n    s_freq = np.zeros((len(time_spect_mask_in), N_col // kf))\n    s_time = np.zeros((N_row // kt, len(freq_spect_mask_in)))\n    j = 0\n    for f in freq_spect_mask_in:\n        if band_size_init == 'half':\n            ind1 = (f - (N_Nyq - 1) * 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\n        elif band_size_init == 'whole':\n            ind1 = (f - 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\n        ind = int(ind1)\n        if ind > N_col - int(kf / 2) - 1:\n            ind = N_col - int(kf / 2) - 1\n        if ind < int(kf / 2):\n            ind = int(kf / 2)\n        i = 0\n        while kt * (i + 1) < N_row:\n            if kf == 1:\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind])\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind] > 100).sum()\n                if n_mesh == 0:\n                    s_time[i, j] = 2\n                else:\n                    s_time[i, j] /= n_mesh\n            else:\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)])\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)] > 100).sum()\n                if n_mesh == 0:\n                    s_time[i, j] = 2\n                else:\n                    s_time[i, j] /= n_mesh\n            i += 1\n        ind_spec.append(ind)\n        j += 1\n    i = 0\n    for t in time_spect_mask_in:\n        ind = int(t // delta_t)\n        if ind > N_row - kt / 2 - 1:\n            ind = N_row - int(kt / 2) - 1\n        if ind < (kt / 2):\n            ind = int(kt / 2)\n        j = 0\n        while (j + 1) * kf < N_col:\n            if kt == 1:\n                s_freq[i, j] = np.sum(spectr_extr[ind, j * kf:(j + 1) * kf])\n                n_mesh = (spectr_extr[ind, j * kf:(j + 1) * kf] > 10).sum()\n                if n_mesh == 0:\n                    s_freq[i, j] = 2\n                else:\n                    s_freq[i, j] /= n_mesh\n            else:\n                s_freq[i, j] = np.sum(spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf])\n                n_mesh = (spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf] > 10).sum()\n                if n_mesh == 0:\n                    s_freq[i, j] = 2\n                else:\n                    s_freq[i, j] /= n_mesh\n\n            j += 1\n        ind_time.append(ind)\n        i += 1\n    s_time = s_time.transpose()\n    if head['att3'] == 0:\n        a = 5.27e8\n    elif head['att3'] == 5:\n        a = 6.21e8\n    return s_freq * (2 ** shift) * t_ng / a, s_time * (2 ** shift) * t_ng / a\n\n\ndef spectr_construction(Spectr, kf, kt):\n    ''' Функция формирует спектр принятого сигнала с требуемым разрешением по частоте и времени. Максимальное\n    разрешение отсчетов по времени 8192 мкс и по частоте 7,8125 МГц. Путем суммирования и усреднерия по kt*kf\n    отсчетам разрешение по частоте и по времени в исходном спектре Spectr уменьшается в kf и kt раз,\n    соответственно. Преобразованный спектр возвращается как S1. Для трехмерного изображения\n    '''\n\n    N_col1 = N_col // kf\n    N_row1 = N_row // kt\n    S1 = np.zeros((N_row1, N_col1))\n\n    for i in range(N_row1):\n        for j in range(N_col1):\n            try:\n                S1[i, j] = np.sum(Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf])\n                N_mesh = (Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf] > 10).sum()\n                if N_mesh == 0:\n                    S1[i, j] = 2\n                else:\n                    S1[i, j] = S1[i, j] / N_mesh\n                if S1[i, j] == 0:\n                    S1[i, j] = 2\n                # if (j > 3) & (S1[i, j] > 1.5 * np.sum(S1[i, j-3:j])//3):\n                #     S1[i, j] = np.sum(S1[i, j-3:j])//3\n                if robust_filter == 'y':\n                    a = param_robust_filter\n                    if (i > 3) & (S1[i, j] < 1 / a * np.sum(S1[i - 3:i - 1, j]) // 2):\n                        S1[i, j] = np.sum(S1[i - 1, j])\n                    if (i > 3) & (S1[i, j] > a * np.sum(S1[i - 3:i - 1, j]) // 2):\n                        # print(S1[i - 3:i+1, j])\n                        S1[i, j] = np.sum(S1[i - 1, j])\n                        # print(S1[i, j])\n                        pass\n\n            except IndexError as allert_message:\n                print(allert_message, 'ind i = ', i, 'ind j = ', j)\n                pass\n            except ValueError as value_message:\n                print(value_message, 'ind i = ', i, 'ind j = ', j)\n                pass\n\n    return S1  # // kt // kf\n\n\ndef path_to_fig():\n    \"\"\" Создает директорию для рисунков обрабатываемого наблюдения, если она до этого не была создана,\n    название директории  совпадает с названием исходного файла данных наблюдения\n    \"\"\"\n    if not os.path.isdir(Path(file_path_data, current_data_file)):\n        os.mkdir(Path(file_path_data, current_data_file))\n    return\n\n\ndef preparing_data():\n    \"\"\" Функция в зависимости от вида данных (полная полоса 1-3 ГГц, половинная полоса 1-2 или 2-3 ГГц,\n    с двумя поляризациями или одной) выдает данные для построения графиков\"\"\"\n\n    # Для полосы 1-3 ГГц и двух возможных поляризаций выдает по два спектра (1-2 и 2-3 ГГц) для каждой поляризации.\n    # Если поляризация не задействована, то соответствующие спектры - пустые. Спектр 1-2 ГГц - в обратном порядке\n    if not (os.path.isfile(Path(file_path_data, current_data_file + '_spectrum.npy')) or os.path.isfile(Path(file_path_data, current_data_file + '_left1.npy'))):\n        if num_of_polar == 2 and band_size_init == 'whole':\n            spectrum, n_aver, measure_kind, band_size, polar = extract_whole_band()\n        if num_of_polar == 2 and band_size_init == 'half':\n            spectrum, n_aver = extract_two_polar()\n    else:\n        spectrum = np.load(Path(file_path_data, current_data_file + '_spectrum.npy'), allow_pickle=True)\n        with open(Path(file_path_data, current_data_file + '_head.bin'), 'rb') as inp:\n            head = pickle.load(inp)\n            n_aver = head['n_aver']\n            band_size = head['band_size']\n            polar = head['polar']\n            # n_aver = head['n_aver']\n\n        # Разделяем составляющие  записи в полной полосе и с возможными двумя поляризациями,\n        # одновременно понижая разрядность данных, меняя их тип с int64 до int32 и уменьшая\n        # занимаемую ими память\n    if num_of_polar == 2 and band_size == 'whole':\n        # if np.size(spectrum[0]) > 1:\n        #     spectrum_left1 = (spectrum[0] / 1000).astype(np.int32)\n        # else:\n        spectrum_left1 = spectrum[0]\n        # if np.size(spectrum[1]) > 1:\n        #     spectrum_left2 = (spectrum[1] / 1000).astype(np.int32)\n        # else:\n        spectrum_left2 = spectrum[1]\n        # if np.size(spectrum[2]) > 1:\n        #     spectrum_right1 = (spectrum[2] / 1000).astype(np.int32)\n        # else:\n        spectrum_right1 = spectrum[2]\n        # if np.size(spectrum[3]) > 1:\n        #     spectrum_right2 = (spectrum[3] / 1000).astype(np.int32)\n        # else:\n        spectrum_right2 = spectrum[3]\n    # Выдает спектры для левой и правой поляризаций шириной по 1 ГГц. При нумерации спектров учитывается\n    # значение зоны Найквиста. С индексом \"1\" - 1-2 ГГц, с индексом \"2\" - 2-3 ГГц, как и для случая выше.\n    # На выходе формально все 4 спектра, но для незадействованной полосы они пустые\n    elif num_of_polar == 2 and band_size == 'half':\n        if N_Nyq == 2:\n            spectrum_left1 = spectrum[0]\n            spectrum_right1 = spectrum[1]\n            spectrum_left2 = []\n            spectrum_right2 = []\n        else:\n            spectrum_left2 = spectrum[0]\n            spectrum_right2 = spectrum[1]\n            spectrum_left1 = []\n            spectrum_right1 = []\n    pass\n\n    return spectrum_left1, spectrum_left2, spectrum_right1, spectrum_right2, int(n_aver), band_size, polar\n\n\ndef unite_spectrum(spec):\n    spec1 = spec[0]\n    spec2 = spec[1]\n    spec3 = spec[2]\n    spec4 = spec[3]\n    ind = []\n    if np.size(spec1) and np.size(spec2):\n        n_row = np.min([np.shape(spec1)[0], np.shape(spec2)[0]])\n        spec1 = spec1[:n_row]\n        spec2 = spec2[:n_row]\n        spec_left = np.hstack((spec1, spec2))\n        ind.append('left_whole')\n    elif np.size(spec1):\n        spec_left = spec1\n        ind.append('left_half1')\n    elif np.size(spec2):\n        spec_left = spec2\n        ind.append('left_half2')\n    else:\n        spec_left = []\n    if np.size(spec3) and np.size(spec4):\n        n_row = np.min([np.shape(spec3)[0], np.shape(spec4)[0]])\n        spec3 = spec3[:n_row]\n        spec4 = spec4[:n_row]\n        spec_right = np.hstack((spec3, spec4))\n        ind.append('right_whole')\n    elif np.size(spec3):\n        spec_right = spec3\n        ind.append('right_half1')\n    elif np.size(spec4):\n        spec_right = spec4\n        ind.append('right_half2')\n    else:\n        spec_right = []\n    if np.size(spec_left) and np.size(spec_right):\n        n_row1 = np.min([np.shape(spec_left)[0], np.shape(spec_right)[0]])\n        spec_left = spec_left[:n_row1]\n        spec_right = spec_right[:n_row1]\n        united_spec = pd.Series([spec_left, spec_right], ind)\n    elif np.size(spec_left):\n        united_spec = pd.Series([spec_left], ind)\n    else:\n        united_spec = pd.Series([spec_right], ind)\n\n    return united_spec\n\n\n# Чтение с диска, если спектры ранее извлекались,\n# или извлечение спектров из исходных записей\nspectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2, n_aver, band_size, polar = \\\n    preparing_data()\naver_param = 2 ** (6 - n_aver)\nkf = int(freq_res / delta_f * aver_param)   # Установка разрешения по частоте в единицах максимального разрешения для\n# данного наблюдения delta_f/aver_param, где delta_f = 7.8125 МГц\nwith open(Path(file_path_data, current_data_file + '_head.bin'), 'rb') as inp:\n    head = pickle.load(inp)\n\n# Выравнивание спектров по результатам шумовых измерений АЧХ\nif align == 'y':\n    if head['att3'] == 5:\n        pos = 1\n    elif head['att3'] == 0:\n        pos = 0\n    path_output = Path(folder_align_path, align_file_name)\n    spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2 = \\\n        align_spectrum(spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2,\n                       head, path_output, pos)\n\n# Приведение порядка следования отсчетов по частоте к нормальному\nif np.size(spectr_extr_left1):\n    N_row = np.shape(spectr_extr_left1)[0]\n    for i in range(N_row):\n        spectr_extr_left1[i][0:] = spectr_extr_left1[i][-1::-1]\nif np.size(spectr_extr_right1):\n    N_row = np.shape(spectr_extr_right1)[0]\n    for i in range(N_row):\n        spectr_extr_right1[i][0:] = spectr_extr_right1[i][-1::-1]\n\nspectrum = pd.Series([spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2])\n\nunited_spectrum = unite_spectrum(spectrum)\nser_ind = united_spectrum.index\nif len(ser_ind) == 2:\n    spectrum_extr = united_spectrum[0] + united_spectrum[1]\nelse:\n    spectrum_extr = united_spectrum[0]\n\n# if noise_calibr == 'y':\n#     spectr_time = calibration(t_cal, spectr_time)\n\n# # ***********************************************\n# # ***        Графический вывод данных        ****\n# # ***********************************************\n\n# Динамическая маска (зависит от длины записи во времени)\nt_spect = N_row * delta_t\n# time_spect_mask = [(lambda i: (t_spect * (i + 0.05)) // 7)(i) for i in range(7)]\ntime_spect_mask = [5, 17, 31, 43, 58]\n# if band_size == 'whole':\n#   freq_spect_mask = []\n\n# Формирование спектров и сканов по маскам freq_spect_mask и time_spect_mask\nshift = head['shift']\nspectr_freq, spectr_time = form_spectr_sp1(spectrum_extr, freq_spect_mask, time_spect_mask)\n\n# Формирование строк-аргументов по времени и частоте и легенды\nN_col = np.shape(spectrum_extr)[1]\nif band_size_init == 'half':\n    freq = np.linspace(1000 * (N_Nyq - 1) + 3.9063 / aver_param * kf, 1000 * N_Nyq - 3.9063 / aver_param * kf,\n                       N_col // kf)\nelif band_size_init == 'whole':\n    freq = np.linspace(1000 + 3.9063 / aver_param * kf, 3000 - 3.9063 / aver_param * kf, N_col // kf)\ntimeS = np.linspace(0, delta_t * N_row, N_row // kt)\n\n# ***************!! Вывод данных в текстовой форме !!*********************\n# path_txt = str(Path(file_path_data, current_data_file, '_scan.txt'))\n# print(path_txt)\n# np.savetxt(path_txt, spectr_freq)\n# path_txt = str(Path(file_path_data, current_data_file, 'freq.txt'))\n# print(path_txt)\n# np.savetxt(path_txt, freq)\n# ***********************************************************************\n\nline_legend_time, line_legend_freq = line_legend(freq_spect_mask[:10])\ninfo_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\n            ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\n            ('polarisation ' + polar), 'align: ' + align]\npath_to_fig()\n\nif parameters['output_picture_mode'] == 'yes':\n    fp.fig_plot(spectr_freq, 0, freq, 1, info_txt, Path(file_path_data, current_data_file), head, line_legend_time)\n    fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, Path(file_path_data, current_data_file), head, line_legend_freq)\n# fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, Path(file_path_data, current_data_file), head, line_legend_freq)\n# *********************************************************\n# ***            Многооконный вывод данных             ****\n# *********************************************************\nif parameters['output_picture_mode'] == 'no':\n    fp.fig_multi_axes(spectr_time, timeS, info_txt, Path(file_path_data, current_data_file),\n                      freq_spect_mask, head)\n\n# *********************************************************\n# ***        Вывод данных двумерный и трехмерный       ****\n# *********************************************************\n# Укрупнение  разрешения по частоте и времени для вывода в 2d и 3d\nif graph_3d_perm == 'y' or contour_2d_perm == 'y':\n    spectr_extr1 = spectr_construction(spectrum_extr, kf, kt)\n# Информация о временном и частотном резрешениях\ninfo_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\n            ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\n            ('polarisation ' + polar)]\npath_to_fig()\n\nif graph_3d_perm == 'y':\n    fp.graph_3d(freq, timeS, spectr_extr1, 0, current_data_file, head)\nif contour_2d_perm == 'y':\n    fp.graph_contour_2d(freq, timeS, spectr_extr1, 0)\n\n# if align == 'y':\n#     align_coeff1 = align_func1(spectr_freq[1, :], 'y', aver_param)\n#     spectr_extr = spectr_extr * align_coeff1\n\n# if graph_3d_perm == 'y':\n#     graph_3d(freq, timeS[n_start_flame:n_stop_flame], spectr_extr1[n_start_flame:n_stop_flame, :], 0)\n# fp.fig_multi_axes(spectr_time[:10, n_start_flame:n_stop_flame], timeS[n_start_flame:n_stop_flame],\n#                   info_txt, file_name0, freq_spect_mask[:10])\n\n\nstop = datetime.now()\nprint('\\n Total time = ', stop - start)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extract_from_binary.py b/extract_from_binary.py
--- a/extract_from_binary.py	(revision b78c9ce82ba6a4c53ceff5d25d89e0125b05ebc4)
+++ b/extract_from_binary.py	(date 1641814656392)
@@ -667,10 +667,13 @@
         ind_time.append(ind)
         i += 1
     s_time = s_time.transpose()
+
     if head['att3'] == 0:
         a = 5.27e8
     elif head['att3'] == 5:
         a = 6.21e8
+    else:
+        a = 6000
     return s_freq * (2 ** shift) * t_ng / a, s_time * (2 ** shift) * t_ng / a
 
 
@@ -849,6 +852,8 @@
         pos = 1
     elif head['att3'] == 0:
         pos = 0
+    else:
+        pos = 1
     path_output = Path(folder_align_path, align_file_name)
     spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2 = \
         align_spectrum(spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2,
Index: Supporting_func/stocks_coefficients.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Any\n\nimport numpy as np\nimport os\nimport sys\nimport pickle\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom Supporting_func.afc_alignment import align_spectrum\nfrom pathlib import Path\n\ncurrent_dir = Path.cwd()\nsys.path.insert(0, current_dir)\n\n\nclass CustomError(Exception):\n    pass\n\n\ndef initial_scan_cut(data):\n    \"\"\" Функция принимает данные с левой поляризацией и определяет индексы центров импульсов\n    меандра с левой поляризацией. Центры импульсов с правой поляризацией принимаются\n    как лежащие посередине между между центрами с левой поляризацией.\n    Функция возвращает массивы индексов центров с левой и правой поляризациями\"\"\"\n\n    data_shape = np.shape(data)\n    j = 0\n    time_row = np.array(data[:, j])\n    time_ind = np.argwhere(time_row > 100)\n\n    # Выбор скана (выбор хорошо заполненного отсчетами скана) для определения\n    # положения центра импульса меандра с левой поляризацией в отсчетах скана\n    while np.size(time_ind) < 0.3 * data_shape[0]:\n        time_row = np.array(data[:, j])\n        j += 1\n        # Выбор индексов ненулевых значений скана\n        time_ind = np.argwhere(time_row > 100)\n\n    # Отсечение начального участка скана до первого контролируемого переключения на\n    # левую поляризацию\n    i = 0\n    while time_ind[i + 1] - time_ind[i] < 25:\n        i += 1\n    # Задание первого элемента для определения скачка индекса ненулевых членов\n    i_prev = int(time_ind[i + 1])\n    time_ind_cut = time_ind[time_ind >= i_prev]\n\n    # ******************************************************************************\n    # Определение центров импульсов меандра с левой поляризацией в отсчетах скана **\n    mean_frame_ind_left = np.array([])\n    frame_ind0 = np.array([])\n    for i in time_ind_cut:\n        # Фрагмент скана с последовательно меняющимися индексами (допускается скачок индекса не более чем на 25)\n        if i - i_prev < 25:\n            frame_ind0 = np.append(frame_ind0, i)\n        else:\n            # Средний индекс отсчетов за полупериод усреднения\n            try:\n                mean_ind = int((np.max(frame_ind0) + np.min(frame_ind0)) / 2)\n            except ValueError:\n                pass\n\n            # if mean_ind - mean_frame_ind_left[-1] < 50 or mean_ind - mean_frame_ind_left[-1] > 70:\n            #     if mean_frame_ind_left[-1] + 60 < data_shape1[0]:\n            #         mean_ind = mean_frame_ind_left[-1] + 60\n            #     else:\n            #             mean_ind = data_shape1[0] - 2\n\n            mean_frame_ind_left = np.append(mean_frame_ind_left, mean_ind)\n            frame_ind0 = np.array([])\n        i_prev = i\n    len_left = np.size(mean_frame_ind_left)\n    mean_frame_ind_right = np.zeros(len_left - 1)\n\n    for k in range(len_left - 1):\n        mean_frame_ind_right[k] = int((mean_frame_ind_left[k] + mean_frame_ind_left[k + 1]) / 2)\n    # Отбрасываем последний элемент вектора центров импульсов левой поляризации, чтобы выровнять\n    # по размеру с вектором центров импульсов правой поляризации\n    mean_frame_ind_left0 = mean_frame_ind_left[: -1]\n    return mean_frame_ind_left0, mean_frame_ind_right\n\n\ndef pol_intensity(data, mean_time_ind):\n    \"\"\" Функция принимает исходную матрицу спектров левой или правой поляризаций и вектор индексов середин\n    полупериодов соответствующих поляризации. Значения усредняются по полупериоду. В усреднении принимают\n    принимают участие значения больше 100. Функция отдает матрицу спектров, усредненных по полупериоду\n    переключения поляризаций. Размерность матрицы по первому индексу уменьшается примерно в 60\n    раз для периода переключения поляризаций 0.5 сек.\"\"\"\n\n    data_shape = data.shape\n    scan_len = np.size(mean_time_ind)\n    pol_spectrum = np.ones((scan_len, data_shape[1])) * 10\n    k2 = 0\n    for j in range(data_shape[1]):\n        time_row = np.array(data[:, j])\n        k1 = 0\n        for i in mean_time_ind:\n            frame = time_row[int(i) - 15:int(i) + 14]\n            pol_spectrum[k1, k2] = np.mean(frame[frame > 100])\n            k1 += 1\n        k2 += 1\n        # plt.grid()\n        # plt.plot(mean_time_ind, pol_spectrum[:, k2 - 1])\n        # plt.show()\n        pass\n    return pol_spectrum\n\n\ndef path_to_data(current_catalog_in, current_data_dir_in):\n    \"\"\" Функция принимает текущий каталог данных (за год или период) и папку текущих данных (за выбранный день).\n    Определяет путь к папке текущих данных на конкретной машине и к корню каталога. \"\"\"\n    head_path1 = Path(r'H:\\Fast_Acquisition')  # Путь к каталогу данных для домашнего ноута\n    head_path2 = Path(r'/media/anatoly/Samsung_T5/Fast_Acquisition')  # Путь к каталогу данных для рабочего компа\n    head_path3 = Path(r'C:\\SCIENCE\\PYTHON 3\\Fast_Acquisition')  # Путь к каталогу данных для ноута ВМ\n    head_path4 = Path(r'I:\\Fast_Acquisition')  # Путь к каталогу данных для notebook 'Khristina'\n\n    if head_path1.is_dir():\n        head_path_out = head_path1\n    elif head_path2.is_dir():\n        head_path_out = head_path2\n    elif head_path3.is_dir():\n        head_path_out = head_path3\n    elif head_path4.is_dir():\n        head_path_out = head_path4\n    else:\n        raise CustomError('Path to data is not found!')\n\n    file_path_data_out = Path(head_path_out, current_catalog_in, current_data_dir_in)\n    return file_path_data_out, head_path_out\n\n\nif __name__ == '__main__':\n    align = 'y'\n\n    current_catalog = r'2021\\Results'  # Текущий каталог (за определенный период, здесь - год)\n    current_data_dir = '2021_12_26sun'  # Папка с текущими данными\n    current_data_file = '2021-12-26_16+00'  # Имя файла с исходными текущими данными без расширения\n    align_file_name: Any = 'Align_coeff.bin'  # Имя файла с текущими коэффициентами выравнивания АЧХ\n    file_path_data, head_path = path_to_data(current_catalog, current_data_dir)\n    path_to_stocks = Path(file_path_data, current_data_file + '_stocks.npy')\n\n    if not (os.path.isfile(path_to_stocks)):\n\n        #               **********************************************\n        # ************** Загрузка матрицы спектров и установок (head) *************\n        with open(Path(file_path_data, current_data_file + '_head.bin'), 'rb') as inp:\n            head = pickle.load(inp)\n        spectrum = np.load(Path(file_path_data, current_data_file + '_spectrum.npy'), allow_pickle=True)\n        #               **********************************************\n\n        if align == 'y':\n            path = Path(head_path, 'Alignment', align_file_name)\n            spectrum1 = align_spectrum(spectrum[0], spectrum[1], spectrum[2], spectrum[3], head,\n                                       path, 1)\n\n        input_data_upper = {'left': spectrum[1],\n                            'right': spectrum[3]}\n        input_data_lower = {'left': spectrum[0],\n                            'right': spectrum[2]}\n\n        a1 = input_data_upper['left']\n        b1 = input_data_upper['right']\n\n        a = input_data_lower['left']\n        # a = a[-1::-1][:]\n        b = input_data_lower['right']\n        # b = b[-1::-1][:]\n        mean_frame_ind_left, mean_frame_ind_right = initial_scan_cut(a)\n\n        c = pol_intensity(a, mean_frame_ind_left)\n        d = pol_intensity(b, mean_frame_ind_right)\n        c1 = pol_intensity(a1, mean_frame_ind_left)\n        d1 = pol_intensity(b1, mean_frame_ind_right)\n        c = np.hstack((c, c1))\n        d = np.hstack((d, d1))\n        # Параметры Стокса\n        s0 = c + d\n        s3 = c - d\n        mean_frame_ind_pol = (mean_frame_ind_right + mean_frame_ind_left) // 2 * 0.008125\n        stocks_coeff = pd.Series([s0, s3, mean_frame_ind_pol])\n        np.save(path_to_stocks, stocks_coeff)\n\n    else:\n        stocks_coeff = np.load(path_to_stocks, allow_pickle=True)\n        [s0, s3, mean_frame_ind_pol] = stocks_coeff\n    for j in range(0, 512, 20):\n        fig, ax1 = plt.subplots()\n        ax2 = ax1.twinx()\n        ax1.plot(mean_frame_ind_pol, s0[:, j], label='x(t)')\n        ax2.plot(mean_frame_ind_pol, s3[:, j], label='y(t)', color='darkred')\n        ax1.set_ylabel('Stocks_I')\n        ax2.set_ylabel('Stocks_V', color='darkred')\n        ax1.minorticks_on()\n        ax1.grid()\n        ax1.grid(which='minor',\n                 axis='x',\n                 color='k',\n                 linestyle=':')\n        plt.show()\n\n    pass\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Supporting_func/stocks_coefficients.py b/Supporting_func/stocks_coefficients.py
--- a/Supporting_func/stocks_coefficients.py	(revision b78c9ce82ba6a4c53ceff5d25d89e0125b05ebc4)
+++ b/Supporting_func/stocks_coefficients.py	(date 1641797882088)
@@ -139,6 +139,8 @@
     file_path_data, head_path = path_to_data(current_catalog, current_data_dir)
     path_to_stocks = Path(file_path_data, current_data_file + '_stocks.npy')
 
+    # Чтение с диска, если спектры ранее извлекались,
+    # или извлечение спектров из исходных записей
     if not (os.path.isfile(path_to_stocks)):
 
         #               **********************************************
Index: Supporting_func/npy_2_txt_converter.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport os\nimport sys\nfrom pathlib import Path\nfrom Supporting_func.stocks_coefficients import path_to_data\n\n\"\"\"Скрипт обращается к записанному файлу в формате *.npy и записывает его в формате *.txt, создавая при этом для \nнего папку, если таковой не существовало. Исходный файл является массивом *.npy и должен формально содержать все \n4 спектра - левая поляризация в двух частотных полосах и правая так же. В текстовом формате спектры записываются \nпоотдельности\"\"\"\n\ncurrent_dir = Path.cwd()\nsys.path.insert(0, Path(current_dir, 'Supporting_func'))\n\nif __name__ == '__main__':\n\n    current_data_file = '2021-06-27_19-28'      # Имя файла с исходными текущими данными без расширения\n    current_data_dir = '2021_06_27sun'          # Папка с текущими данными\n    current_catalog = r'2021/Results'           # Текущий каталог (за определенный период, здесь - год)\n    date = current_data_file[0:10]\n    year = current_data_file[0:4]\n\n    folder_data_path, head_path = path_to_data(current_catalog, current_data_dir)\n    file_data_path = Path(folder_data_path, current_data_file + '_spectrum.npy')\n    folder_data_txt_path = Path(head_path, year, date + 'sun_txt')\n    file_suffixes = ['_left1.txt', '_left2.txt', '_right1.txt', '_right2.txt']\n\n    #               ******** Считывание *********\n    spectrum = np.load(file_data_path, allow_pickle=True)\n    #               ********** Запись ***********\n    if not os.path.isdir(folder_data_txt_path):\n        os.makedirs(folder_data_txt_path)\n    for i in range(4):\n        np.savetxt(Path(folder_data_txt_path, current_data_file + file_suffixes[i]), spectrum[i])\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Supporting_func/npy_2_txt_converter.py b/Supporting_func/npy_2_txt_converter.py
--- a/Supporting_func/npy_2_txt_converter.py	(revision b78c9ce82ba6a4c53ceff5d25d89e0125b05ebc4)
+++ b/Supporting_func/npy_2_txt_converter.py	(date 1641827513982)
@@ -14,15 +14,15 @@
 
 if __name__ == '__main__':
 
-    current_data_file = '2021-06-27_19-28'      # Имя файла с исходными текущими данными без расширения
-    current_data_dir = '2021_06_27sun'          # Папка с текущими данными
+    current_data_file = '2021-12-26_05+08'      # Имя файла с исходными текущими данными без расширения
+    current_data_dir = '2021_12_26_3C84'          # Папка с текущими данными
     current_catalog = r'2021/Results'           # Текущий каталог (за определенный период, здесь - год)
     date = current_data_file[0:10]
     year = current_data_file[0:4]
 
     folder_data_path, head_path = path_to_data(current_catalog, current_data_dir)
     file_data_path = Path(folder_data_path, current_data_file + '_spectrum.npy')
-    folder_data_txt_path = Path(head_path, year, date + 'sun_txt')
+    folder_data_txt_path = Path(head_path, year, date + '_3C84_txt')
     file_suffixes = ['_left1.txt', '_left2.txt', '_right1.txt', '_right2.txt']
 
     #               ******** Считывание *********
Index: Interface/window_interface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Interface.Window_D import Ui_MainWindow\nimport sys\nfrom pathlib import Path\nfrom PyQt5 import QtWidgets\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtCore import Qt\nfrom Interface.parameters import param_dict\nimport pickle\nimport os\n\n__all__ = ['main', 'ExampleApp']\n\n\nclass ExampleApp(QtWidgets.QMainWindow, Ui_MainWindow):\n\n    def __init__(self, param_dict_str):\n        # Это здесь нужно для доступа к переменным, методам\n        # и т.д. в файле design.py\n        super().__init__()\n        self.setupUi(self)  # Это нужно для инициализации нашего дизайна\n\n        # Начальные установки\n        self.freq_res = param_dict_str['freq_res']\n        self.time_res = param_dict_str['time_res']\n        self.frequency_mask = []\n        self.index_freq_mask = None\n        self.time_mask = []\n        self.index_time_mask = None\n        self.file_name = ' '\n        self.file_folder = ' '\n        self.catalog = param_dict_str['path_to_catalog']\n        self.lne_frequency_resolution.setText(self.freq_res)\n        self.lne_time_resolution.setText(self.time_res)\n        self.gB_pattrens.adjustSize()\n        self.param_dict = param_dict_str\n        self.rbn_one_window.setChecked(True)\n        # print(f'path to catalog: {self.catalog}')\n\n        # Работа с масками по частоте и времени. Устанавливаем начальные маски по частоте, которые взяты из\n        # словаря param_dict_str по ключу 'freq_mask'.\n        self.tableWidget_freq_patterns.setColumnWidth(0, 450)\n        freq_mask = param_dict_str['freq_mask']\n        k = 0\n        for unit in freq_mask:\n            item_freq = self.tableWidget_freq_patterns.item(k, 0)\n            item_freq.setText(unit)\n            self.tableWidget_freq_patterns.setItem(k, 0, item_freq)\n            k += 1\n\n        self.tableWidget_time_patterns.setColumnWidth(0, 450)\n        time_mask = param_dict_str['time_mask']\n        k = 0\n        for unit in time_mask:\n            item_time = self.tableWidget_time_patterns.item(k, 0)\n            item_time.setText(unit)\n            self.tableWidget_time_patterns.setItem(k, 0, item_time)\n            k += 1\n\n        self.btn_load_setup.adjustSize()\n        self.btn_load_setup.clicked.connect(self.set_initial_setup)\n        # Кнопки поиска/выбора файла для обработки и передачи управления обработчику выбора параметров\n        self.btn_find_file.clicked.connect(self.find_processing_file)\n        self.cbx_save_current_parameters.adjustSize()\n\n        self.btn_set_parameters.adjustSize()\n        self.btn_set_parameters.clicked.connect(self.set_parameter_handler)  # Выполнить функцию set_parameter_handler\n        # при нажатии кнопки\n\n    def __set_attr(self, name, value):\n        self.__dict__[name] = value\n        # print(self.__dict__[name])\n        pass\n\n    def set_initial_setup(self):\n        init_dict = self.param_dict\n        with open('save_param.bin', 'rb') as inp:\n            param_set = pickle.load(inp)[-1]\n        # print(f'param_set = {param_set}')\n        self.__set_attr('index_freq_mask', param_set['ind_freq_checkbox'])\n        self.__set_attr('index_time_mask', param_set['ind_time_checkbox'])\n        self.__set_attr('frequency_mask', param_set['freq_mask'])\n        self.__set_attr('time_mask', param_set['time_mask'])\n        self.__set_attr('freq_res', param_set['freq_res'])\n        self.__set_attr('time_res', param_set['time_res'])\n        self.__set_attr('file_name', param_set['file_name'])\n        self.__set_attr('file_folder', param_set['file_folder'])\n        self.__set_attr('path_to_catalog', param_set['path_to_catalog'])\n        self.lne_frequency_resolution.setText(self.freq_res)\n        self.lne_time_resolution.setText(self.time_res)\n        self.__set_attr('catalog', str(Path(param_set['path_to_catalog'], param_set['file_folder'])))\n\n        self.lne_oserv_file.setText(self.lne_oserv_file.text() + self.file_name)\n        self.lne_file_name.setText(self.lne_file_name.text() + self.file_name)\n\n        a = param_set['file_folder']\n        # print(f'path to catalog: {self.catalog}, file folder: {a}')\n        # print(f'ind_freq_mask: {self.index_freq_mask}, freq_mask = {self.frequency_mask}')\n        freq_mask = init_dict['freq_mask']\n        if self.index_freq_mask is not None:\n            i = self.index_freq_mask\n            try:\n                freq_mask[i] = self.frequency_mask\n            except IndexError:\n                freq_mask.append(self.frequency_mask)\n\n        k = 0\n        for unit in freq_mask:\n            item_freq = self.tableWidget_freq_patterns.item(k, 0)\n            item_freq.setText(unit)\n            self.tableWidget_freq_patterns.setItem(k, 0, item_freq)\n            k += 1\n\n        time_mask = init_dict['time_mask']\n        k = 0\n        if self.index_time_mask is not None:\n            i = self.index_time_mask\n            try:\n                time_mask[i] = self.time_mask\n            except IndexError:\n                time_mask.append(self.time_mask)\n        for unit in time_mask:\n            item_time = self.tableWidget_time_patterns.item(k, 0)\n            item_time.setText(unit)\n            self.tableWidget_time_patterns.setItem(k, 0, item_time)\n            k += 1\n        pass\n\n    def __save_latest_setup(self, state):\n        if state == Qt.Checked:\n            # print(f'Save_latest - file_folder: {self.file_folder}, file_name: {self.file_name}')\n            parameter_dict = {'freq_res': self.freq_res,\n                              'time_res': self.time_res,\n                              'freq_mask': self.frequency_mask,\n                              'time_mask': self.time_mask,\n                              'file_name': self.file_name,\n                              'file_folder': self.file_folder,\n                              'path_to_catalog': self.catalog,\n                              'ind_freq_checkbox': self.index_freq_mask,\n                              'ind_time_checkbox': self.index_time_mask}\n            self.__save_parameters(parameter_dict)\n        pass\n\n    def __save_parameters(self, data):\n        if not (os.path.isfile('save_param.bin')):\n            head = [None]\n            with open('save_param.bin', 'wb') as out:\n                pickle.dump(head, out)\n\n        with open('save_param.bin', 'rb') as inp:\n            head = pickle.load(inp)\n            head.append(data)\n            print(head)\n        with open('save_param.bin', 'wb') as out:\n            pickle.dump(head, out)\n\n    def set_parameter_handler(self):\n\n        # Обработка выбранных на закладке параметров разрешения\n        res_time = self.lne_time_resolution.text()\n        res_frequency = self.lne_frequency_resolution.text()\n        if int(res_time) < 8:\n            message_box_time = QMessageBox.information(self, 'Time resolution verification',\n                                                       'Your resolution too small or negative! '\n                                                       'Set the resolution greater or equal then 8 and divisible by 8')\n            message_box_time.move(self, 200, 400)\n        else:\n            self.__set_attr('time_res', res_time)\n        if int(res_frequency) < 1:\n            QMessageBox.critical(self, 'Frequency resolution verification', 'Your resolution too small or negative! '\n                                                                            'Set the resolution greater then 1')\n        else:\n            self.__set_attr('freq_res', res_frequency)\n\n        # Работа с QTableWidget для выбора или редактирования масок по частоте и времени.\n        # Маска По частоте\n        n = self.tableWidget_freq_patterns.rowCount()\n        count_choose = 0\n        for i in range(n):\n            item_freq = self.tableWidget_freq_patterns.item(i, 0)\n            a_freq = item_freq.checkState()\n            # print(a_freq, item_freq)\n\n            if a_freq == 2:\n                self.__set_attr('index_freq_mask', i)\n                count_choose += 1\n                if count_choose > 1:\n                    print(\"Wrong choose frequency mask!!!\")\n                else:\n                    freq_mask_choose_str = item_freq.text()\n                    self.__set_attr('frequency_mask', freq_mask_choose_str)\n        if count_choose == 0:\n            QMessageBox.critical(self, 'Frequency pattern verification', 'Choose frequency pattern! '\n                                                                         'Set the frequency pattern!')\n        # Маска По времени\n        n = self.tableWidget_time_patterns.rowCount()\n        count_choose = 0\n        for i in range(n):\n            item_time = self.tableWidget_time_patterns.item(i, 0)\n            a_time = item_time.checkState()\n\n            if a_time == 2:\n                self.__set_attr('index_time_mask', i)\n                count_choose += 1\n                if count_choose > 1:\n                    print(\"Wrong choose frequency mask!!!\")\n                else:\n                    time_mask_choose_str = item_time.text()\n                    self.__set_attr('time_mask', time_mask_choose_str)\n        if count_choose == 0:\n            QMessageBox.critical(self, 'Time pattern verification', 'Choose time pattern! '\n                                 'Set the time pattern!')\n            # Сохранение текущих настроек\n        self.__save_latest_setup(self.cbx_save_current_parameters.checkState())\n        pass\n\n    def find_processing_file(self):\n        \"\"\" Функция обработчик принимает клик кнопкой и возвращает в виде аттрибутов объекта класса название\n        файла для обработки и папки в котором он лежит\"\"\"\n        path_to_folder = self.catalog  # Исходная папка поиска файла для обработки\n        # Результат поиска\n        res = QFileDialog.getOpenFileNames(self, 'Open file', path_to_folder, 'BinaryFile (*.bin);;NumpyFile (*.npy)')\n        res_part = res[0][0].split('/')\n\n        file_name = res_part[-1][:-4]\n        file_folder = res_part[-2]\n        self.__set_attr('file_name', file_name)\n        self.__set_attr('file_folder', file_folder)\n        print(f'file_folder: {file_folder}, file_name: {file_name}')\n        self.lne_oserv_file.setText(self.lne_oserv_file.text() + self.file_name)\n        self.lne_file_name.setText(self.lne_file_name.text() + self.file_name)\n\n        print(f'file_folder: {self.file_folder}, file_name: {self.file_name}')\n        pass\n\n\ndef main():\n    app = QtWidgets.QApplication(sys.argv)  # Новый экземпляр QApplication\n    param_dict_str = param_dict_to_str(param_dict())\n    window = ExampleApp(param_dict_str)  # Создаём объект класса ExampleApp\n    window.show()  # Показываем окно\n    app.exec_()  # и запускаем приложение\n\n    freq_mask_num = list_str_to_num(window.frequency_mask)\n    time_mask_num = list_str_to_num(window.time_mask)\n\n    # print(window.frequency_mask, type(window.frequency_mask))\n    parameters_dict = {'freq_res': int(window.freq_res),\n                       'time_res': int(window.time_res),\n                       'freq_mask': freq_mask_num,\n                       'time_mask': time_mask_num,\n                       'file_name': window.file_name,\n                       'file_folder': window.file_folder,\n                       'output_picture_mode': 'yes' if window.rbn_one_window.isChecked() == True else \"no\"}\n    return parameters_dict\n\n\ndef num_to_str(b):\n    \"\"\" Принимает двумерный массив типа list, возвращает одномерный массив строк типа list \"\"\"\n    return list(map(lambda x: str(x)[1:-1], b))\n\n\ndef param_dict_to_str(dict):\n    \"\"\" Принимает словарь с разноформатными параметрами обработки данных, возвращает словарь с параметрами\n    преобразованными в строковый формат\"\"\"\n    freq_mask_str = num_to_str(dict['freq_mask'])\n    time_mask_str = num_to_str(dict['time_mask'])\n    dict_str = {'freq_res': str(dict['freq_resolution']),\n                'time_res': str(dict['time_resolution']),\n                'freq_mask': freq_mask_str,\n                'time_mask': time_mask_str,\n                # 'file_folder': dict['file_folder'],\n                'path_to_catalog': dict['path_to_catalog']}\n    return dict_str\n\n\ndef list_str_to_num(list_str):\n    return list(map(lambda x: int(x), list_str.split(', ')))\n\n\nif __name__ == '__main__':\n    parameter = main()\n    time_res = parameter['time_res']\n    freq_res = parameter['freq_res']\n    file_name = parameter['file_name']\n    file_folder = parameter['file_folder']\n    freq_mask = parameter['freq_mask']\n    time_mask = parameter['time_mask']\n    picture_mode = parameter['output_picture_mode']\n    print(f'time_res = {time_res}, freq_res = {freq_res}, file_name = {file_name}, file_folder= {file_folder},'\n          f' freq_mask = {freq_mask}, time_mask = {time_mask}, picture mode = {picture_mode}')\n\n# # объект приложения\n# app = QApplication(sys.argv)\n#\n# # QMainWindow объект\n# main_window = QMainWindow()\n#\n# # Это класс Ui_MainWindow, реализованный дизайнером qt\n# ui_components = Ui_MainWindow()\n# # Вызвать метод setupUi () для регистрации в объекте QMainWindow\n# ui_components.setupUi(main_window)\n\n# Шоу\n# main_window.show()\n#\n# sys.exit(app.exec_())\n\n\n# if __name__ == '__main__':\n#     print(call_wind())\n\n\n# self.listWidget.clear()  # На случай, если в списке уже есть элементы\n# directory = QtWidgets.QFileDialog.getExistingDirectory(self, \"ClickButton\")\n# # открыть диалог выбора директории и установить значение переменной\n# # равной пути к выбранной директории\n#\n# if directory:  # не продолжать выполнение, если пользователь не выбрал директорию\n#     for file_name in os.listdir(directory):  # для каждого файла в директории\n#         self.listWidget.addItem(file_name)   # добавить файл в listWidget\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Interface/window_interface.py b/Interface/window_interface.py
--- a/Interface/window_interface.py	(revision b78c9ce82ba6a4c53ceff5d25d89e0125b05ebc4)
+++ b/Interface/window_interface.py	(date 1642060892949)
@@ -74,8 +74,9 @@
     def set_initial_setup(self):
         init_dict = self.param_dict
         with open('save_param.bin', 'rb') as inp:
-            param_set = pickle.load(inp)[-1]
-        # print(f'param_set = {param_set}')
+            param_set_com = pickle.load(inp)
+            param_set = param_set_com[-1]
+        print(f'param_set = {param_set}')
         self.__set_attr('index_freq_mask', param_set['ind_freq_checkbox'])
         self.__set_attr('index_time_mask', param_set['ind_time_checkbox'])
         self.__set_attr('frequency_mask', param_set['freq_mask'])
Index: save_param.bin
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>�\u0004��$\u0000\u0000\u0000\u0000\u0000\u0000]�(N}�(�\bfreq_res��\u00011��\btime_res��\u00018��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001A10, 20, 30, 40, 50, 60, 70��\tfile_name��\u00102021-06-28_01+18��\u000Bfile_folder��\u000E2021_06_28crab��\u000Fpath_to_catalog��7/media/anatoly/Samsung_T5/Fast_Acquisition/2021/Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0000u}�(�\bfreq_res��\u00014��\btime_res�h\u0005�\tfreq_mask��:1050, 1465, 1535, 1600, 1601, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-06-27_00+22��\u000Bfile_folder��\r2021_06_27sun��\u000Fpath_to_catalog��7/media/anatoly/Samsung_T5/Fast_Acquisition/2021/Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res�h\u0005�\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001A10, 20, 30, 40, 50, 60, 70��\tfile_name��\u00142021-12-17_02_riska7��\u000Bfile_folder��\u000E2021-12-17test��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0000u}�(�\bfreq_res��\u0003128��\btime_res��\u0003512��\tfreq_mask��\u00042880��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00112021-12-22_01_-08��\u000Bfile_folder��\u00102021_12_22cygnus��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-24_04+16��\u000Bfile_folder��\r2021_12_24sun��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000232��\btime_res��\u0003512��\tfreq_mask��\"2800, 2830, 2860, 2890, 2920, 2950��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00112021-12-22_01_-08��\u000Bfile_folder��\u00102021_12_22cygnus��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003150��\btime_res��\u00042100��\tfreq_mask��\u00041480��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-06-28_03+14��\u000Bfile_folder��\u000E2021_06_28crab��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000216��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-25_01+24��\u000Bfile_folder��\r2021_12_25sun��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00162021-12-25_01_bb_05_00��\u000Bfile_folder��\u000E2021_12_25test��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00162021-12-25_01_bb_05_00��\u000Bfile_folder��\u000E2021_12_25test��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000232��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-25_05+08��\u000Bfile_folder��\u000F2021_12_25_3c84��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000232��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-24_03+12��\u000Bfile_folder��\u000E2021_12_24crab��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000232��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-23_02+12��\u000Bfile_folder��\u000E2021_12_23crab��\u000Fpath_to_catalog��/H:\\Fast_Acquisition\\2021\\Results\\2021_12_24crab��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_01+28��\u000Bfile_folder��\r2021_12_26sun��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000264��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_02+18��\u000Bfile_folder��\u00102021_12_26source��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003128��\btime_res��\u0003512��\tfreq_mask��\u001C2700, 2720, 2730, 2740, 2760��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_02+18��\u000Bfile_folder��\u00102021_12_26source��\u000Fpath_to_catalog��1H:\\Fast_Acquisition\\2021\\Results\\2021_12_26source��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003128��\btime_res��\u0003512��\tfreq_mask��\u001C2700, 2720, 2730, 2740, 2760��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_02+18��\u000Bfile_folder��\u00102021_12_26source��\u000Fpath_to_catalog��1H:\\Fast_Acquisition\\2021\\Results\\2021_12_26source��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u000232��\btime_res��\u0003512��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003200��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog��0H:\\Fast_Acquisition\\2021\\Results\\2021_12_26_3C84��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003200��\btime_res��\u0003512��\tfreq_mask��\u00042800��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog��0H:\\Fast_Acquisition\\2021\\Results\\2021_12_26_3C84��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003300��\btime_res��\u00041024��\tfreq_mask��\u00042850��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog��@H:\\Fast_Acquisition\\2021\\Results\\2021_12_26_3C84\\2021_12_26_3C84��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003300��\btime_res��\u00041024��\tfreq_mask��\u00042850��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_04+10��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003300��\btime_res��\u00041024��\tfreq_mask��\u00042850��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog�� I:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00112021-12-22_10_-12��\u000Bfile_folder��\r2021_12_22sun��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003250��\btime_res��\u00041024��\tfreq_mask��\u00042875��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00112021-12-22_01_+16��\u000Bfile_folder��\u000E2021_12_22moon��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000232��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_09+12��\u000Bfile_folder��\r2021_12_26sun��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000232��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u001F2021-12-21_04_RP_ng_att-05_head��\u000Bfile_folder��\u000E2021_12_21test��\u000Fpath_to_catalog��.H:\\Fast_Acquisition\\2021\\Results\\2021_12_26sun��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u001A2021-12-21_04_RP_ng_att-05��\u000Bfile_folder��\u000E2021_12_21test��\u000Fpath_to_catalog�� H:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_01+28��\u000Bfile_folder��\r2021_12_26sun��\u000Fpath_to_catalog�� I:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u000264��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u001A2021-12-21_01_RP_ng_att-00��\u000Bfile_folder��\u000E2021_12_21test��\u000Fpath_to_catalog�� I:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res�h\u0005�\btime_res��\u00045000��\tfreq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u001A2021-12-21_01_RP_ng_att-00��\u000Bfile_folder��\u000E2021_12_21test��\u000Fpath_to_catalog�� I:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0002�\u0011ind_time_checkbox�K\u0001u}�(�\bfreq_res��\u0003300��\btime_res��\u00041024��\tfreq_mask��\u00042850��\ttime_mask��\u001D20, 40, 60, 80, 100, 120, 140��\tfile_name��\u00102021-12-26_03+12��\u000Bfile_folder��\u000F2021_12_26_3C84��\u000Fpath_to_catalog�� I:\\Fast_Acquisition\\2021\\Results��\u0011ind_freq_checkbox�K\u0003�\u0011ind_time_checkbox�K\u0001ue.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/save_param.bin b/save_param.bin
--- a/save_param.bin	(revision b78c9ce82ba6a4c53ceff5d25d89e0125b05ebc4)
+++ b/save_param.bin	(date 1641797244590)
@@ -1,8 +1,5 @@
-���$      ]�(N}�(�freq_res��1��time_res��8��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��10, 20, 30, 40, 50, 60, 70��	file_name��2021-06-28_01+18��file_folder��2021_06_28crab��path_to_catalog��7/media/anatoly/Samsung_T5/Fast_Acquisition/2021/Results��ind_freq_checkbox�K�ind_time_checkbox�K u}�(�freq_res��4��time_res�h�	freq_mask��:1050, 1465, 1535, 1600, 1601, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-06-27_00+22��file_folder��
+��      ]�(N}�(�freq_res��1��time_res��8��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��10, 20, 30, 40, 50, 60, 70��	file_name��2021-06-28_01+18��file_folder��2021_06_28crab��path_to_catalog��7/media/anatoly/Samsung_T5/Fast_Acquisition/2021/Results��ind_freq_checkbox�K�ind_time_checkbox�K u}�(�freq_res��4��time_res�h�	freq_mask��:1050, 1465, 1535, 1600, 1601, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-06-27_00+22��file_folder��
 2021_06_27sun��path_to_catalog��7/media/anatoly/Samsung_T5/Fast_Acquisition/2021/Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res�h�	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��10, 20, 30, 40, 50, 60, 70��	file_name��2021-12-17_02_riska7��file_folder��2021-12-17test��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�K u}�(�freq_res��128��time_res��512��	freq_mask��2880��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-22_01_-08��file_folder��2021_12_22cygnus��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-24_04+16��file_folder��
 2021_12_24sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��"2800, 2830, 2860, 2890, 2920, 2950��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-22_01_-08��file_folder��2021_12_22cygnus��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��150��time_res��2100��	freq_mask��1480��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-06-28_03+14��file_folder��2021_06_28crab��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��16��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-25_01+24��file_folder��
 2021_12_25sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-25_01_bb_05_00��file_folder��2021_12_25test��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-25_01_bb_05_00��file_folder��2021_12_25test��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-25_05+08��file_folder��2021_12_25_3c84��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-24_03+12��file_folder��2021_12_24crab��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-23_02+12��file_folder��2021_12_23crab��path_to_catalog��/H:\Fast_Acquisition\2021\Results\2021_12_24crab��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_01+28��file_folder��
-2021_12_26sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��64��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��128��time_res��512��	freq_mask��2700, 2720, 2730, 2740, 2760��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog��1H:\Fast_Acquisition\2021\Results\2021_12_26source��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��128��time_res��512��	freq_mask��2700, 2720, 2730, 2740, 2760��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog��1H:\Fast_Acquisition\2021\Results\2021_12_26source��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��200��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��0H:\Fast_Acquisition\2021\Results\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��200��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��0H:\Fast_Acquisition\2021\Results\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��@H:\Fast_Acquisition\2021\Results\2021_12_26_3C84\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_04+10��file_folder��2021_12_26_3C84��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog�� I:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-22_10_-12��file_folder��
-2021_12_22sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��250��time_res��1024��	freq_mask��2875��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-22_01_+16��file_folder��2021_12_22moon��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��32��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_09+12��file_folder��
-2021_12_26sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��32��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-21_04_RP_ng_att-05_head��file_folder��2021_12_21test��path_to_catalog��.H:\Fast_Acquisition\2021\Results\2021_12_26sun��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-21_04_RP_ng_att-05��file_folder��2021_12_21test��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_01+28��file_folder��
-2021_12_26sun��path_to_catalog�� I:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��64��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-21_01_RP_ng_att-00��file_folder��2021_12_21test��path_to_catalog�� I:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res�h�time_res��5000��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2530, 2720, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-21_01_RP_ng_att-00��file_folder��2021_12_21test��path_to_catalog�� I:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog�� I:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Kue.
\ No newline at end of file
+2021_12_26sun��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��64��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��128��time_res��512��	freq_mask��2700, 2720, 2730, 2740, 2760��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog��1H:\Fast_Acquisition\2021\Results\2021_12_26source��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��128��time_res��512��	freq_mask��2700, 2720, 2730, 2740, 2760��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_02+18��file_folder��2021_12_26source��path_to_catalog��1H:\Fast_Acquisition\2021\Results\2021_12_26source��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��32��time_res��512��	freq_mask��:1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��200��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��0H:\Fast_Acquisition\2021\Results\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��200��time_res��512��	freq_mask��2800��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��0H:\Fast_Acquisition\2021\Results\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_03+12��file_folder��2021_12_26_3C84��path_to_catalog��@H:\Fast_Acquisition\2021\Results\2021_12_26_3C84\2021_12_26_3C84��ind_freq_checkbox�K�ind_time_checkbox�Ku}�(�freq_res��300��time_res��1024��	freq_mask��2850��	time_mask��20, 40, 60, 80, 100, 120, 140��	file_name��2021-12-26_04+10��file_folder��2021_12_26_3C84��path_to_catalog�� H:\Fast_Acquisition\2021\Results��ind_freq_checkbox�K�ind_time_checkbox�Kue.
\ No newline at end of file
