Index: Supporting_func/Fig_plot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom pathlib import Path\r\nimport pylab\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.font_manager as font_manager\r\nfrom matplotlib.ticker import MaxNLocator, ScalarFormatter, FixedLocator\r\nfrom tkinter import *\r\nfrom tkinter import messagebox as mb\r\n# from IPython.display import set_matplotlib_formats\r\n# set_matplotlib_formats('svg')\r\n\r\n''' На входе программы несколько пар строк с данными и координатами, причем количество точек, в общем случае, разное для \r\n    разных пар. В программу передается легенда и название осей. \r\n    Программа создает сетку, надписывает оси, дает легенду.\r\n'''\r\n\r\n\r\ndef save_fig(func):\r\n    \"\"\" Функция-декоратор для сохранения в одноименную с файлом данных папку рисунков временных сканов и спектров\r\n    в выделенные моменты времени.\"\"\"\r\n    def wrapper(*args):\r\n        figure, file_name, flag = func(*args)\r\n        add_pass1 = path_to_pic(file_name + '\\\\', flag)\r\n        path = Path(file_name, add_pass1)\r\n        figure.savefig(path)\r\n        del figure\r\n        flag_save = save_question()\r\n        if flag_save == 'no':\r\n            if os.path.isfile(path):\r\n                os.remove(path)\r\n                print('Picture is not saved')\r\n            else:\r\n                print('File not found')\r\n        else:\r\n            print('Picture is saved')\r\n        return\r\n    return wrapper\r\n\r\n\r\ndef save_question():\r\n    root = Tk()\r\n    answer = mb.askquestion(\r\n        title=\"Save control\",\r\n        message=\"Save picture?\")\r\n    root.mainloop()\r\n    del root\r\n    return answer\r\n\r\n\r\n@save_fig\r\ndef fig_plot(spectr1, burn, argument, flag, inform, file_name0_path, head, line_legend=[2] * 20):\r\n    file_name0 = str(file_name0_path)\r\n    size_sp1 = spectr1.shape\r\n\r\n    for i in range(size_sp1[0]):\r\n        for j in range(size_sp1[1]):\r\n            if spectr1[i, j] < 2:\r\n                spectr1[i, j] = 'NaN'\r\n\r\n    freq_line_sp1 = size_sp1[0]\r\n\r\n    fig, ax = plt.subplots(1, figsize=(12, 6))\r\n\r\n    line_color = ['green', 'blue', 'purple', 'lime', 'black', 'red', 'olivedrab', 'lawngreen', 'magenta', 'dodgerblue']\r\n\r\n    # Show the major grid lines with dark grey lines\r\n    plt.grid(b=True, which='major', color='#666666', linestyle='-')\r\n\r\n    # Show the minor grid lines with very faint and almost transparent grey lines\r\n    plt.minorticks_on()\r\n    plt.grid(b=True, which='minor', color='#999999', linestyle='-', alpha=0.5)\r\n\r\n    title1, title2, title02 = title_func(file_name0, head)\r\n\r\n    y_max = np.nanmax(spectr1)\r\n    y_min = np.nanmin(spectr1)\r\n    x_min = argument.min()\r\n    x_max = argument.max()\r\n\r\n    if flag:\r\n        ax.set_xlabel('Freq, MHz', fontsize=18)\r\n        ax.set_yscale('log')\r\n        ax.set_ylabel('Power Spectrum', fontsize=20)\r\n        ax.set_title(title02 + title1, fontsize=18)\r\n        y1 = y_min * 2\r\n        y2 = y_min\r\n        y3 = y_max - (y_max - y_min) / 10\r\n        y4 = y_min * 4\r\n    else:\r\n        # pylab.xlim(x_min, x_max + 100)\r\n        plt.legend(loc='upper right')\r\n        ax.set_xlabel('Time, sec', fontsize=18)\r\n        if burn == 1:\r\n            ax.set_yticks([0, 1])\r\n            ax.set_ylim(0, 4)\r\n        ax.set_ylabel('Intensity', fontsize=18)\r\n        ax.set_title(title2 + ' scan ' + title1, fontsize=20)\r\n        y1 = y_max - 3 * (y_max - y_min) / 10\r\n        y2 = y_max - 4 * (y_max - y_min) / 10\r\n        y3 = y_max - (y_max - y_min) / 10\r\n        y4 = y_max - (y_max - y_min) / 5\r\n\r\n    plt.text(x_min, y1, inform[0], fontsize=16)  # Разрешение по частоте\r\n    plt.text(x_min, y2, inform[1], fontsize=16)  # Разрешение по времени\r\n    plt.text(x_min, y3, inform[2], fontsize=16)  # Информация о поляризации\r\n    plt.text(x_min, y4, inform[3], fontsize=16)  # Информация о статистической чистке сканов\r\n    m = 0\r\n    for i in range(freq_line_sp1):\r\n        ax.plot(argument, spectr1[i, :], color=line_color[m], label=line_legend[i])\r\n        m += 1\r\n\r\n    if False:\r\n        set_zoom = 6.5, 11.5, 1.425e6, 1.5e6\r\n        axins = insert_zoom(ax, argument, spectr1[6, :], line_color[6], line_legend[6], set_zoom)\r\n        ax.indicate_inset_zoom(axins, edgecolor=\"black\")\r\n\r\n    # Управление шрифтом легенды\r\n    font = font_manager.FontProperties(family='Comic Sans MS',\r\n                                       weight='bold',\r\n                                       style='normal', size=16)\r\n    ax.legend(prop=font)\r\n    ax.legend(loc=10, prop=font, bbox_to_anchor=(1, 0.5))\r\n\r\n    plt.show()\r\n    # print(f'type fig: {type(fig)}')\r\n    return fig, file_name0, flag\r\n\r\n\r\ndef insert_zoom(ax, argument, ordinate, line_color, line_legend, set_zoom, set_pos=[0.5, 0.05, 0.35, 0.35]):\r\n    \"\"\" Функция вставляет в родительский рисунок matplotlib увеличенное изображение его части. Принимает объект\r\n    родительского рисунка, тот же массив\r\n    аргументов и значений функции, что и родительский, стиль линии, если речь идет о графике, расположение левого\r\n    нижнего угла вставки и ее размеры set_pos (относительно левого нижнего угла родителя в долях размера родительского рисунка),\r\n    границы выделенной области set_zoom. Возвращает объект-рисунок для размещения на родительском рисунке.\"\"\"\r\n    sf = ScalarFormatter()\r\n    sf.set_powerlimits((-4, 4))\r\n    axins = ax.inset_axes(set_pos)\r\n    axins.plot(argument, ordinate, color=line_color, label=line_legend)\r\n    axins.minorticks_on()\r\n    axins.grid(b=True, which='major', color='#666666', linestyle='-')\r\n    axins.grid(b=True, which='minor', color='#999999', linestyle='-', alpha=0.5)\r\n    # sub region of the original image\r\n    x1, x2, y1, y2 = set_zoom\r\n    axins.set_xlim(x1, x2)\r\n    axins.set_ylim(y1, y2)\r\n    axins.set_xticklabels('')\r\n    axins.yaxis.set_major_formatter(sf)\r\n    # axins.set_yticklabels('')\r\n    return axins\r\n\r\n\r\ndef title_func(file_name0, head):\r\n    az = file_name0[-3:]\r\n    att1 = str(head['att1'])\r\n    att2 = str(head['att2'])\r\n    att3 = str(head['att3'])\r\n    date = head['date'][:-1]\r\n\r\n    title1 = date + ', az = ' + az + ', Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n    if not file_name0.find('sun') == -1:\r\n        title2 = 'Sun intensity'\r\n        title02 = 'Sun spectrum '\r\n        if file_name0[-1:] == 'b':\r\n            az = file_name0[-4:-1]\r\n            title2 = 'Calibration'\r\n            title02 = 'Calibration spectrum '\r\n            title1 = date + ', az = ' + az + ', Black Body/Sky, Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n\r\n    elif not file_name0.find('crab') == -1:\r\n        title2 = 'Crab intensity'\r\n        title02 = 'Crab spectrum '\r\n\r\n    elif not file_name0.find('calibration') == -1:\r\n        title2 = 'Calibration'\r\n        title02 = 'Calibration spectrum '\r\n        title1 = date + ', az = ' + az + ', Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n\r\n    elif not (file_name0.find('test') == -1):\r\n        kind = file_name0[-2:]\r\n        title2 = 'Test'\r\n        title02 = 'Test spectrum'\r\n        if kind == 'VG':\r\n            power_vg = 0\r\n            title1 = date + ', Vector Gen' + ', P = ' + str(power_vg) + 'dBm, ' \\\r\n                'Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n        elif kind == 'NG':\r\n            t_noise = 6300\r\n            title1 = date + ', Noise Gen, ' + 'T = ' + str(t_noise) + 'K, Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n        elif kind == 'ML':\r\n            title1 = date + ', Matched Load' ', Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n        elif kind == 'SC':\r\n            title1 = date + ', Short Cut' ', Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n        else:\r\n            title1 = date + ', ' + ' , Att = [' + att1 + ', ' + att2 + ', ' + att3 + ']'\r\n\r\n    else:\r\n        title2 = 'Scan'\r\n        title02 = 'Spectrum'\r\n\r\n    return title1, title2, title02\r\n\r\n\r\n@save_fig\r\ndef fig_multi_axes(spectr1, argument, inform, file_name0path, freq_mask, head):\r\n    \"\"\" Функция строит многооконный рисунок, принимает numpy-массив в качестве значений (первый индекс массива -\r\n    число графиков-окон), аргумент, информацию о свойствах графиков (разрешение по времени и частоте, поляризация), путь\r\n    к файлу данных, характеристики файла данных head, список параметра freq_mask, каждому значению из которого\r\n    соответствует свой график-окно. Максимальное количество окон задается n_row_pic, n_col_pic, и по умолчанию -\r\n     2 * 3 = 6.\r\n     Выдает рисунок как объект Figure matplotlib и сохраняет его в формате png в папку одноименную с file_name0path в\r\n     той же директории, где находится файл данных\"\"\"\r\n\r\n    file_name0 = str(file_name0path)\r\n    size_sp1 = spectr1.shape\r\n    freq_line_sp1 = size_sp1[0]\r\n    n_col_pic, n_row_pic = config_fig_multi_axes(freq_line_sp1)\r\n\r\n    title1, title2, title02 = title_func(file_name0, head)\r\n\r\n    fig, axes = plt.subplots(n_row_pic, n_col_pic, figsize=(12, 6))\r\n\r\n    # line_colore = ['green', 'blue', 'purple', 'lime', 'black', 'red', 'olivedrab', 'lawngreen',\r\n    # 'magenta', 'dodgerblue']\r\n\r\n    fig.suptitle(title2 + ' scan' + title1, y=1.0, fontsize=24)\r\n\r\n    for i_freq in range(freq_line_sp1):\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].plot(argument[0: -2], spectr1[i_freq, 0: -2])\r\n\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].set_title(str(freq_mask[i_freq]) + ' MHz')\r\n        # Show the major grid lines with dark grey lines\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].grid(b=True, which='major', color='#666666', linestyle='-')\r\n        # Show the minor grid lines with very faint and almost transparent grey lines\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].minorticks_on()\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].grid(b=True, which='minor', color='#999999', linestyle='-', alpha=0.5)\r\n        # axes[i_phantom // 3, i_phantom % 3].set_yticks([0, 1])\r\n        # axes[i_phantom // 3, i_phantom % 3].set_ylim(0, 4)\r\n        # axes[i_phantom // 3, i_phantom % 3].set_xlabel('t, sec', fontsize=10)\r\n\r\n        xticks = axes[i_freq // n_col_pic, i_freq % n_col_pic].get_xticks().tolist()\r\n        xticks[-2:] = ''\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].xaxis.set_major_locator(FixedLocator(xticks))\r\n        # Установление формата отображения меток по оси 0у - при порядке выше 4 он выносится на верх оси\r\n        sf = ScalarFormatter()\r\n        sf.set_powerlimits((-4, 4))\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].yaxis.set_major_formatter(sf)\r\n        # *************************************************************************\r\n\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].xaxis.set_label_coords(1.05, -0.025)\r\n        axes[i_freq // n_col_pic, i_freq % n_col_pic].annotate('t, sec', xy=(0.95, -0.05), ha='left', va='top',\r\n                                               xycoords='axes fraction', fontsize=10)\r\n\r\n    axes[-1, -1].axis('off')\r\n    fig.text(0.68, 0.25, inform[2], fontsize=14)\r\n    fig.text(0.68, 0.2, inform[0], fontsize=14)\r\n    fig.text(0.68, 0.15, inform[1], fontsize=14)\r\n    # plt.figtext(0.11, 0.25, 'time')\r\n    # axes[0, 2].legend(loc=10, bbox_to_anchor=(1.2, 0.5))\r\n    plt.subplots_adjust(hspace=0.4)\r\n    plt.show()\r\n\r\n    # Управление шрифтом легенды\r\n    font = font_manager.FontProperties(family='Comic Sans MS',\r\n                                       weight='bold',\r\n                                       style='normal', size=16)\r\n    # add_pass1 = path_to_pic(file_name0, 0)\r\n    # fig.savefig(Path(file_name0, add_pass1))\r\n    return fig, file_name0, 0\r\n\r\n\r\ndef config_fig_multi_axes(n):\r\n\r\n    if n == 11:\r\n        n_col, n_row = (4, 3)\r\n    elif n == 10:\r\n        n_col, n_row = (4, 3)\r\n    elif n == 9:\r\n        n_col, n_row = (4, 3)\r\n    elif n == 8:\r\n        n_col, n_row = (3, 3)\r\n    elif n == 7:\r\n        n_col, n_row = (3, 3)\r\n    elif n == 6:\r\n        n_col, n_row = (3, 3)\r\n    elif n == 5:\r\n        n_col, n_row = (3, 2)\r\n    elif n == 4:\r\n        n_col, n_row = (3, 2)\r\n    elif n == 3:\r\n        n_col, n_row = (2, 2)\r\n    elif n == 2:\r\n        n_col, n_row = (2, 2)\r\n\r\n    return n_col, n_row\r\n\r\n\r\ndef path_to_pic(file_path, flag, format='png'):\r\n    if flag == 1:\r\n        add_pass0 = 'spectrum_00'\r\n    elif flag == 2:\r\n        add_pass0 = 'colour2D_00'\r\n    elif flag == 3:\r\n        add_pass0 = 'pic3D_00'\r\n    else:\r\n        add_pass0 = 'scan_00'\r\n\r\n    l = len(add_pass0)\r\n    add_pass1 = add_pass0 + '.' + format\r\n    if not os.path.isfile(Path(file_path, add_pass1)):\r\n        pass\r\n    else:\r\n        while os.path.isfile(Path(file_path, add_pass1)):\r\n            num = int(add_pass0[l - 2:l]) + 1\r\n            num_str = str(num)\r\n            if num >= 10:\r\n                add_pass0 = add_pass0[:l - 2] + num_str\r\n            else:\r\n                add_pass0 = add_pass0[:l - 2] + '0' + num_str\r\n            add_pass1 = add_pass0 + '.' + format\r\n\r\n    return add_pass1\r\n\r\n\r\ndef graph_contour_2d(*args):\r\n    import matplotlib.font_manager as font_manager\r\n    xval, yval, z, s = args\r\n    x, y = np.meshgrid(xval, yval)\r\n    z = np.log10(z)\r\n\r\n    levels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())\r\n    # pick the desired colormap, sensible levels, and define a normalization\r\n    # instance which takes data values and translates those into levels.\r\n    cmap = plt.get_cmap('jet')\r\n\r\n    fig, ax1 = plt.subplots(1, figsize=(12, 6))\r\n\r\n    cf = ax1.contourf(x, y, z, levels=levels, cmap=cmap)\r\n\r\n    x_min = xval[1]\r\n    y1 = yval[0] + (yval[-1] - yval[0]) * 0.05\r\n    y2 = yval[0] + (yval[-1] - yval[0]) * 0.1\r\n    fig.colorbar(cf, ax=ax1)\r\n    title1, title2 = pic_title()\r\n    ax1.set_title(title2 + ' ' + title1, fontsize=20)\r\n    ax1.set_xlabel('Freq, MHz', fontsize=18)\r\n    ax1.set_ylabel('Time, s', fontsize=18)\r\n\r\n    plt.grid(b=True, which='major', color='#666666', linestyle='-')\r\n    plt.minorticks_on()\r\n    plt.grid(b=True, which='minor', color='#999999', linestyle='-', alpha=0.5)\r\n    plt.tick_params(axis='both', which='major', labelsize=16)\r\n\r\n    plt.text(x_min, y1, info_txt[0], fontsize=16)\r\n    plt.text(x_min, y2, info_txt[1], fontsize=16)\r\n\r\n    # adjust spacing between subplots so `ax1` title and `ax0` tick labels\r\n    # don't overlap\r\n    fig.tight_layout()\r\n    add_path0 = fp.path_to_pic(file_name0 + '\\\\', 2, 'png')\r\n    fig.savefig(file_name0 + '\\\\' + add_path0)\r\n    plt.show()\r\n    return\r\n\r\n    # Модуль проверки: формировалась ли ранее матрица спектра по времени и частоте\r\n    # если - нет, то идем в extract(file_name0), если - да, то загружаем\r\n\r\n\r\ndef graph_3d(*args):\r\n    from mpl_toolkits.mplot3d import Axes3D\r\n    from matplotlib import cm\r\n    fig = plt.figure(figsize=(12, 8))\r\n    ax = fig.add_subplot(1, 1, 1, projection='3d')\r\n    xval, yval, z, s, file_name, head = args\r\n    x, y = np.meshgrid(xval, yval)\r\n    ax.zaxis._set_scale('log')  # Расставляет tiks логарифмически\r\n    title1, title2, title3 = title_func(file_name, head)\r\n    ax.set_title(title2 + ' ' + title1, fontsize=20)\r\n    # ax.text2D(0.05, 0.75, info_txt[0], transform=ax.transAxes, fontsize=16)\r\n    # ax.text2D(0.05, 0.65, info_txt[1], transform=ax.transAxes, fontsize=16)\r\n    ax.set_xlabel('Frequency, MHz', fontsize=16)\r\n    ax.set_ylabel('Time, s', fontsize=16)\r\n    plt.tick_params(axis='both', which='major', labelsize=14)\r\n    # cmap = plt.get_cmap('jet')\r\n    if s:\r\n        surf = ax.plot_surface(x, y, z, rstride=2, cstride=2, cmap=cm.plasma)\r\n        plt.savefig(file_name + '_wK' + '.png', format='png', dpi=100)\r\n        return\r\n    surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap=cm.jet)\r\n    add_path0 = path_to_pic(file_name + '\\\\', 3)\r\n    # plt.savefig(file_name + '\\\\' + add_path0, format='png', dpi=100)\r\n    plt.show()\r\n    return\r\n\r\n\r\nif __name__ == '__main__':\r\n    fig_plot()\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Supporting_func/Fig_plot.py b/Supporting_func/Fig_plot.py
--- a/Supporting_func/Fig_plot.py	(revision f55d514b029802551262170933084570e518def9)
+++ b/Supporting_func/Fig_plot.py	(date 1636628763608)
@@ -296,7 +296,7 @@
     return n_col, n_row
 
 
-def path_to_pic(file_path, flag, format='png'):
+def path_to_pic(file_path, flag, format='svg'):
     if flag == 1:
         add_pass0 = 'spectrum_00'
     elif flag == 2:
Index: .idea/Fast_Asquisition_Bin_Base.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv1\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv_39\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9 (venv_39)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Fast_Asquisition_Bin_Base.iml b/.idea/Fast_Asquisition_Bin_Base.iml
--- a/.idea/Fast_Asquisition_Bin_Base.iml	(revision f55d514b029802551262170933084570e518def9)
+++ b/.idea/Fast_Asquisition_Bin_Base.iml	(date 1636368296157)
@@ -6,7 +6,7 @@
       <excludeFolder url="file://$MODULE_DIR$/venv" />
       <excludeFolder url="file://$MODULE_DIR$/venv_39" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.9 (venv_39)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.9" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9 (venv_39)\" project-jdk-type=\"Python SDK\" />\r\n  <component name=\"PyPackaging\">\r\n    <option name=\"earlyReleasesAsUpgrades\" value=\"true\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision f55d514b029802551262170933084570e518def9)
+++ b/.idea/misc.xml	(date 1636368296191)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (venv_39)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
   <component name="PyPackaging">
     <option name="earlyReleasesAsUpgrades" value="true" />
   </component>
Index: extract_from_binary.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport os\r\nimport sys\r\nimport pandas as pd\r\nimport pickle\r\nimport json as jsn\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nfrom Supporting_func import Fig_plot as fp, align_spectrum, path_to_data\r\n# from Supporting_func import align_spectrum, path_to_data\r\nfrom Interface import main\r\nfrom Interface.window_handler import exec_app\r\n\r\ncurrent_dir = Path.cwd()\r\nhome_dir = Path.home()\r\n\r\nsys.path.insert(0, Path(current_dir, 'Supporting_func'))\r\nsys.path.insert(0, Path(current_dir, 'Interface'))\r\nstart = datetime.now()\r\n\r\nparameters = main()\r\ncurrent_data_file = parameters['file_name']      # Имя файла с исходными текущими данными без расширения\r\ncurrent_data_dir = parameters['file_folder']          # Папка с текущими данными\r\n\r\nalign_file_name = 'Align_coeff.bin'         # Имя файла с текущими коэффициентами выравнивания АЧХ\r\ncurrent_catalog = r'2021/Results'           # Текущий каталог (за определенный период, здесь - год)\r\n\r\nfile_path_data, head_path = path_to_data(current_catalog, current_data_dir)\r\nfolder_align_path = Path(head_path, 'Alignment')\r\ndate = current_data_file[0:11]\r\n\r\n# !!!! ******************************************* !!!!\r\n# ****** Блок исходных параметров для обработки *******\r\n\r\n\r\nfreq_res = parameters['freq_res']  # Установка разрешения по частоте в МГц\r\nkt = parameters['time_res'] // 8  # Установка разрешения по времени в единицах минимального разрешения 8.1925e-3 сек\r\n\r\nN_Nyq = 2   # Номер зоны Найквиста\r\nshift = 0  # Усечение младших разрядов при обработке первичного бинарного файла данных\r\n# *****************************************************\r\n\r\ndelta_t = 8.1925e-3\r\ndelta_f = 7.8125\r\nnum_of_polar = 2  # Параметр равен \"1\" для записей до 12.12.2020 и \"2\" для записей после 12.12.2020\r\nif num_of_polar == 1:\r\n    q = int(current_data_file[-1])\r\n    N_Nyq = q\r\nband_size_init = 'whole'\r\n# band_size = 'whole'   Параметр 'whole' означает работу в диапазоне 1-3 ГГц, 'half' - диапазон 1-2 или 2-3 ГГц\r\n# polar = 'both'        Принимает значения поляризаций: 'both', 'left', 'right'\r\nrobust_filter = 'n'\r\nparam_robust_filter = 1.1\r\nalign = 'y'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ ('y' / 'n')\r\n\r\nnoise_calibr = 'n'\r\ngraph_3d_perm = 'y'\r\ncontour_2d_perm = 'n'\r\n\r\nif N_Nyq == 3:\r\n    freq_spect_mask = [2120, 2300, 2700, 2820, 2900]  # 2060, 2750, 2760, 2770, 2780, 2790, 2800, 2810,\r\n    # 2820, 2830, 2850, 2880, 2900, 2950# Временные сканы Солнца на этих частотах\r\nelif band_size_init == 'whole':\r\n    n1 = 2\r\n    n2 = 9\r\n    freq_spect_mask = parameters['freq_mask']\r\n    # freq_spect_mask = [2060, 2220, 2300, 2500, 2560, 2700, 2800, 2880, 2980]\r\n    # freq_spect_mask = [1080, 1140, 1360, 1420, 1620, 1780, 1980]\r\n    # freq_spect_mask = [1535,  2450, 2550, 2750,  2800, 2950]\r\n    # freq_spect_mask = [1000 * n1 + 100 * n2 + 10 * i for i in range(10)]\r\n    # freq_spect_mask = [1050, 1465, 1500, 1535, 1600, 1700, 1750, 1950]\r\n    # freq_spect_mask = [1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920]\r\n    # freq_spect_mask = [1140, 1420, 1480, 2460, 2500, 2780] # for Crab '2021-06-28_03+14'\r\n    # freq_spect_mask = [1220, 1540, 1980, 2060, 2500, 2780] # for Crab '2021-06-28_04+12'\r\nelse:\r\n    freq_spect_mask = [1171, 1380, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920]\r\n\r\ntime_spect_mask = [47, 84.4, 104, 133, 133.05, 177.02, 177.38]  # Срез частотного спектра в эти моменты времени\r\n\r\natt_val = [i * 0.5 for i in range(64)]\r\natt_dict = {s: 10 ** (s / 10) for s in att_val}\r\npass\r\n\r\n\r\ndef extract():\r\n    file_name = Path(file_path_data, current_data_file + '.bin')\r\n    file_name_out = Path(file_path_data, current_data_file + '.txt')\r\n    i = 0\r\n    k = 0\r\n    spectr = []\r\n    frame = ' '\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n\r\n        f_in = open(file_name, 'rb')\r\n\r\n        while frame:\r\n\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\r\n            for k in range(129):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n\r\n                else:\r\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    spectr_frame.append(spectr_val)\r\n                    pass\r\n\r\n            spectr.append(spectr_frame)\r\n            print(i, frame_num)\r\n            i += 1\r\n\r\n        pass\r\n\r\n        spectr.pop(-1)\r\n        N = len(spectr)\r\n        n_frame_last = spectr[-1][0]\r\n        rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n        if rest:\r\n            for k in range(rest):\r\n                spectr.pop(-1)\r\n        print(n_frame_last, spectr[-1][0])\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n\r\n        spectr1 = convert_to_matrix(spectr, spectr[-1][0] + 1, n_aver)\r\n    np.savetxt(file_name_out, spectr1, header=(str(n_aver) + '-n_aver ' + str(bound_left) + '-kurt'))\r\n\r\n    return spectr1, n_aver\r\n\r\n\r\ndef extract_two_polar():\r\n    file_name = file_name0 + '.bin'\r\n    # file_name_out = file_name0 + '.txt'\r\n    # *********** Если система работает с одной поляризацией ************\r\n    if not file_name0.find('Ant2') == -1:\r\n        antenna2_0 = 1\r\n    else:\r\n        antenna2_0 = 0\r\n    # *******************************************************************\r\n    i = 0\r\n    k = 0\r\n    spectr_left = []\r\n    spectr_right = []\r\n    attenuators = []\r\n    frame = ' '\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n\r\n        f_in = open(file_name, 'rb')\r\n        antenna = 0\r\n        while frame:\r\n\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\r\n            for k in range(130):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n                elif k == 1:\r\n                    att_1 = frame_int & 0x3F\r\n                    att_2 = (frame_int & 0xFC0) >> 6\r\n                    att_3 = (frame_int & 0x3F000) >> 12\r\n                    noise_gen_on = (frame_int & 0x40000) >> 18\r\n                    antenna_before = antenna\r\n                    antenna = (frame_int & 0x80000) >> 19\r\n                    coupler = (frame_int & 0x100000) >> 20\r\n                    band = (frame_int & 0x8000000000000000) >> 63\r\n                    attenuators = [att_1, att_2, att_3]\r\n\r\n                    pass\r\n\r\n                else:\r\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    if pp_good / 256 < 0.78125:\r\n                        spectr_val = 2\r\n                    spectr_frame.append(spectr_val)\r\n                    pass\r\n\r\n            if antenna == 0 and (antenna_before - antenna == 0):\r\n                spectr_left.append(spectr_frame)\r\n            elif len(spectr_left) > 1 and ((antenna_before - antenna) != 0):\r\n                spectr_left.pop(-1)\r\n\r\n            if antenna == 1 and (antenna_before - antenna) == 0:\r\n                spectr_right.append(spectr_frame)\r\n            elif len(spectr_right) > 1 and ((antenna_before - antenna) != 0):\r\n                spectr_right.pop(-1)\r\n            print(i, frame_num, band)\r\n            i += 1\r\n\r\n        pass\r\n        n_right = len(spectr_right)\r\n        n_left = len(spectr_left)\r\n\r\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\r\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\r\n        # то необходима следующая процедура перестановки значений переменных\r\n        if n_right == 0 and antenna2_0 == 1:\r\n            spectr_right = spectr_left\r\n            spectr_left = []\r\n            n_right = len(spectr_right)\r\n            n_left = len(spectr_left)\r\n        # **********************************************************************************\r\n        if n_right > 1:\r\n            spectr_right.pop(-1)\r\n            n_frame_last = spectr_right[-1][0]\r\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n            if rest:\r\n                for k in range(rest):\r\n                    spectr_right.pop(-1)\r\n            print(n_frame_last, spectr_right[-1][0])\r\n        if n_left > 1:\r\n            spectr_left.pop(-1)\r\n            n_frame_last = spectr_left[-1][0]\r\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n            if rest:\r\n                for k in range(rest):\r\n                    spectr_left.pop(-1)\r\n            print(n_frame_last, spectr_left[-1][0])\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n\r\n    if n_left > 1:\r\n        spectr1 = convert_to_matrix(spectr_left, spectr_left[-1][0] + 1, n_aver)\r\n    else:\r\n        spectr1 = []\r\n    if n_right > 1:\r\n        spectr2 = convert_to_matrix(spectr_right, spectr_right[-1][0] + 1, n_aver)\r\n    else:\r\n        spectr2 = []\r\n    spectrum_extr = pd.Series([spectr1, spectr2])\r\n    np.save(file_name0 + '_spectrum', spectrum_extr)\r\n    head = np.array([n_aver, 6, 8])\r\n    np.savetxt(file_name0 + '_head.txt', head)\r\n    return spectrum_extr, n_aver\r\n\r\n\r\ndef extract_whole_band():\r\n    file_name = Path(file_path_data, current_data_file + '.bin')\r\n    # *********** Если система работает с одной поляризацией ************\r\n    if not str(file_name).find('Ant2') == -1:\r\n        antenna2_0 = 1\r\n    else:\r\n        antenna2_0 = 0\r\n    # *******************************************************************\r\n    i = 0\r\n    spectrum_right_1 = []\r\n    spectrum_left_1 = []\r\n    spectrum_left_2 = []\r\n    spectrum_right_2 = []\r\n    attenuators = []\r\n    frame = ' '\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n            return\r\n\r\n        f_in = open(file_name, 'rb')\r\n        antenna = 0\r\n        while frame:\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [2:129]\r\n            for k in range(130):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n                elif k == 1:\r\n                    att_1 = frame_int & 0x3F\r\n                    att_1 = int((63 - att_1) / 2)\r\n                    att_2 = (frame_int & 0xFC0) >> 6\r\n                    att_2 = int((63 - att_2) / 2)\r\n                    att_3 = (frame_int & 0x3F000) >> 12\r\n                    att_3 = int((63 - att_3) / 2)\r\n                    noise_gen_on = (frame_int & 0x40000) >> 18\r\n                    antenna_before = antenna\r\n                    antenna = (frame_int & 0x80000) >> 19\r\n                    if antenna == 1:\r\n                        pass\r\n                    coupler = (frame_int & 0x100000) >> 20\r\n                    band = (frame_int & 0x8000000000000000) >> 63\r\n                    attenuators = [att_1, att_2, att_3]\r\n                    if i == 10:\r\n                        att01 = att_1\r\n                        att02 = att_2\r\n                        att03 = att_3\r\n                    pass\r\n\r\n                else:\r\n                    spectrum_val = (frame_int & 0x7FFFFFFFFFFFFF) >> shift\r\n\r\n                    # Отбросили \"shift\" младших разрядов двоичного представления или 3 разряда десятичного\r\n                    # при \"shift=10\"\r\n                    if band:\r\n                        spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_1]))\r\n                    else:\r\n                        spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_2]))\r\n                    if spectrum_val > 1000000000:\r\n                        spectrum_val = 1000000000\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    if pp_good / 256 < 0.1:\r\n                        spectrum_val = 2\r\n                    spectr_frame.append(spectrum_val)\r\n                    pass\r\n\r\n            if antenna == 0 and (antenna_before - antenna == 0):\r\n                if band:\r\n                    spectrum_left_2.append(spectr_frame)\r\n                else:\r\n                    spectrum_left_1.append(spectr_frame)\r\n            if len(spectrum_left_1) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_left_1.pop(-1)\r\n            if len(spectrum_left_2) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_left_2.pop(-1)\r\n\r\n            if antenna == 1 and (antenna_before - antenna) == 0:\r\n                if band:\r\n                    spectrum_right_2.append(spectr_frame)\r\n                else:\r\n                    spectrum_right_1.append(spectr_frame)\r\n            if len(spectrum_right_1) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_right_1.pop(-1)\r\n            if len(spectrum_right_2) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_right_2.pop(-1)\r\n\r\n            print(i, frame_num, band, attenuators)\r\n            i += 1\r\n        pass\r\n        n_right1 = len(spectrum_right_1)\r\n        n_left1 = len(spectrum_left_1)\r\n        n_right2 = len(spectrum_right_2)\r\n        n_left2 = len(spectrum_left_2)\r\n\r\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\r\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\r\n        # то необходима следующая процедура перестановки значений переменных\r\n        n_right = np.max([len(spectrum_right_1), len(spectrum_right_2)])\r\n        if n_right == 0 and antenna2_0 == 1:\r\n            spectrum_right_1 = spectrum_left_1\r\n            spectrum_left_1 = []\r\n            spectrum_right_2 = spectrum_left_2\r\n            spectrum_left_2 = []\r\n            n_right1 = len(spectrum_right_1)\r\n            n_left1 = len(spectrum_left_1)\r\n            n_right2 = len(spectrum_right_2)\r\n            n_left2 = len(spectrum_left_2)\r\n\r\n        # Приведение длины записи к величине кратной количеству частот\r\n        if n_right1 > 1:\r\n            spectrum_right_1 = cut_spectrum(spectrum_right_1, n_aver)\r\n            # spectrum_right_1 = np.array(spectrum_right_1, dtype=np.int32)\r\n            spectrum_right_1 = parts_to_numpy(spectrum_right_1, n_right1)\r\n        if n_left1 > 1:\r\n            spectrum_left_1 = cut_spectrum(spectrum_left_1, n_aver)\r\n            spectrum_left_1 = np.array(spectrum_left_1, dtype=np.int32)\r\n        if n_right2 > 1:\r\n            spectrum_right_2 = cut_spectrum(spectrum_right_2, n_aver)\r\n            # spectrum_right_2 = np.array(spectrum_right_2, dtype=np.int32)\r\n            spectrum_right_2 = parts_to_numpy(spectrum_right_2, n_right2)\r\n        if n_left2 > 1:\r\n            spectrum_left_2 = cut_spectrum(spectrum_left_2, n_aver)\r\n            spectrum_left_2 = np.array(spectrum_left_2, dtype=np.int32)\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n    spectrum_extr = pd.Series([spectrum_left_1, spectrum_left_2, spectrum_right_1, spectrum_right_2])\r\n    # head = [n_aver, shift, bound_left, bound_right, att01, att02, att03]\r\n    band_size, polar, measure_kind = status_func(n_left1, n_left2, n_right1, n_right2)\r\n\r\n    head = {'date': date,\r\n            'measure_kind': measure_kind,    # Вид измерений: наблюдение Солнца, Луны, калибровка АЧХ\r\n            'band_size': band_size,  # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\r\n            # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\r\n            'polar': polar,  # Принимает значения поляризаций: 'both', 'left', 'right'\r\n            'cleaned': 'no',\r\n            'n_aver': n_aver,\r\n            'shift': shift,\r\n            'kurtosis': bound_left,\r\n            'att1': att01,\r\n            'att2': att02,\r\n            'att3': att03,\r\n            'align_file_path': r'F:\\Fast_Acquisition\\Alignment\\Align_coeff.bin',\r\n            'align_coeff_pos': 5}\r\n    return save_spectrum(spectrum_extr, head)\r\n\r\n\r\ndef parts_to_numpy(list_arr, len_list):\r\n    \"\"\" Функция превращает список в массив numpy.\r\n    Разбивает файл на меньшие части и обрабатывает их поотдельности. По ходу завершинея обработки частей\r\n    происходит объединение обработанных частей.\"\"\"\r\n    n = int(len_list // 1e5)\r\n    k = int(len_list % 1e5)\r\n    numpy_arr = []\r\n    for i in range(n + 1):\r\n        if i == n:\r\n            auxiliary = list_arr[int(i * 1e5):int(i * 1e5 + k)]\r\n            auxiliary = np.array(auxiliary, dtype='int32')\r\n        else:\r\n            auxiliary = list_arr[int(i * 1e5):int((i + 1) * 1e5)]\r\n            auxiliary = np.array(auxiliary, dtype='int32')\r\n        l = np.size(numpy_arr)\r\n        if l:\r\n            numpy_arr = np.vstack([numpy_arr, auxiliary])\r\n        else:\r\n            numpy_arr = auxiliary\r\n\r\n    return numpy_arr\r\n\r\n\r\ndef status_func(n_left1, n_left2, n_right1, n_right2):\r\n\r\n    # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\r\n    # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\r\n    if (n_left1 > 1 and n_left2 > 1) or (n_right1 > 1 and n_right2 > 1):\r\n        band_size = 'whole'\r\n    if (n_left1 > 1 or n_right1 > 1) and (n_left2 <= 1 and n_right2 <= 1):\r\n        band_size = 'half_low'\r\n    if (n_left2 > 1 or n_right2 > 1) and (n_left1 <= 1 and n_right1 <= 1):\r\n        band_size = 'half_upper'\r\n\r\n    # polar Принамает значения поляризаций: 'both', 'left', 'right'\r\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 <= 1 or n_right2 <= 1):\r\n        polar = 'left'\r\n    if (n_left1 <= 1 or n_left2 <= 1) and (n_right1 > 1 or n_right2 > 1):\r\n        polar = 'right'\r\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 > 1 or n_right2 > 1):\r\n        polar = 'both'\r\n\r\n    # Определение вида измерений: наблюдение Солнца, Луны, калибровка АЧХ\r\n    measure_kind = ''\r\n    file_name0 = str(Path(file_path_data, current_data_file))\r\n    if file_name0.find('test') != -1:\r\n        # l = file_name0.find('test')\r\n        measure_kind = 'test'\r\n    if file_name0.find('sun') != -1:\r\n        measure_kind = 'Sun'\r\n    if file_name0.find('moon') != -1:\r\n        measure_kind = 'Moon'\r\n    if file_name0.find('calibration') != -1:\r\n        measure_kind = 'calibration'\r\n\r\n    return band_size, polar, measure_kind\r\n\r\n\r\ndef save_spectrum(spectrum_extr, head):\r\n    spectrum1 = spectrum_extr[0]\r\n    spectrum2 = spectrum_extr[1]\r\n    spectrum3 = spectrum_extr[2]\r\n    spectrum4 = spectrum_extr[3]\r\n    n_aver = head['n_aver']\r\n    band_size = head['band_size']\r\n    polar = head['polar']\r\n    measure_kind = head['measure_kind']\r\n    print(f'len_spectrum1 = {len(spectrum1)}, len_spectrum2 ={len(spectrum2)}, len_spectrum3 ={len(spectrum3)}, '\r\n          f'len_spectrum4 ={len(spectrum4)}')\r\n    if len(spectrum1) > 1:\r\n        spectrum1_low = convert_to_matrix(spectrum1, spectrum1[-1][0] + 1, n_aver)\r\n        pass\r\n    else:\r\n        spectrum1_low = []\r\n    if len(spectrum2) > 1:\r\n        spectrum1_high = convert_to_matrix(spectrum2, spectrum2[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum1_high = []\r\n    if len(spectrum3) > 1:\r\n        spectrum2_low = convert_to_matrix(spectrum3, spectrum3[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum2_low = []\r\n    if len(spectrum4) > 1:\r\n        spectrum2_high = convert_to_matrix(spectrum4, spectrum4[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum2_high = []\r\n    spectrum_whole = pd.Series([spectrum1_low, spectrum1_high, spectrum2_low, spectrum2_high])\r\n    np.save(Path(file_path_data, current_data_file + '_spectrum'), spectrum_whole)\r\n    with open(Path(file_path_data, current_data_file + '_head.bin'), 'wb') as out:\r\n        pickle.dump(head, out)\r\n    jsn.dump(head, open(Path(file_path_data, current_data_file + '_head.txt'), \"w\"))\r\n    # np.savetxt(file_name0 + '_head.bin', head)\r\n\r\n    return spectrum_whole, n_aver, measure_kind, band_size, polar\r\n\r\n\r\ndef cut_spectrum(spectrum, n_aver):\r\n    spectrum.pop(-1)\r\n    n_frame_last = spectrum[-1][0]\r\n    rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n    if rest:\r\n        for k in range(rest):\r\n            spectrum.pop(-1)\r\n    print(n_frame_last, spectrum[-1][0])\r\n    return spectrum\r\n\r\n\r\ndef convert_to_matrix(S_total, counter, n_aver):\r\n    \"\"\"Функция принимает список списков S, который формируется в extract(file_name0) и превращает его в матрицу,\r\n    строки которой - спектры с разрешением 7.8125/(2**(6-n_aver)) МГц, а столбцы - зависимость значения\r\n    спектра на фиксированной частоте от времени. Разрешение по времени - 8192 мкс. Вместо пропущенных пакетов\r\n    вставляет значение 2\"\"\"\r\n    len_time = np.shape(S_total)[0]\r\n    S = [[int(2)] * 128 for i in range(counter)]\r\n    # S = [['NaN'] * 128 for i in range(counter)]\r\n    for s in S_total:\r\n        S[s[0]] = s[1:]\r\n    aver_param_loc = 2 ** (6 - n_aver)\r\n    n = 128 * aver_param_loc\r\n    print(len(S))\r\n    k = int(len(S) // n)\r\n    print(f' n = {n}, k = {k}')\r\n    parts = int(k // 100)\r\n    rest = int(k % 100)\r\n    s_agreed = []\r\n\r\n    for i in range(parts +1):\r\n        if i == parts:\r\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i * 100 + rest) * n)])\r\n            s_ar = np.reshape(s_auxiliary, (-1, n))\r\n        else:\r\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i + 1) * 100 * n)])\r\n            s_ar = np.reshape(s_auxiliary, (-1, n))\r\n        l = np.size(s_agreed)\r\n        if l:\r\n            s_agreed = np.vstack([s_agreed, s_ar])\r\n        else:\r\n            s_agreed = s_ar\r\n\r\n    # s_agreed = np.array(S[0: k * n])\r\n    print(f'len_s_agreed = {len(s_agreed)}, shape = {np.shape(s_agreed)}')\r\n    # s_ar = np.reshape(s_agreed, (-1, n))\r\n    return s_agreed\r\n\r\n\r\ndef line_legend(freq_mask):\r\n    N_col_leg = len(freq_mask)\r\n    N_row_leg = len(time_spect_mask)\r\n    legend_freq = [0] * N_col_leg\r\n    legend_time = [0] * N_row_leg\r\n    i1 = 0\r\n    for i in freq_mask:\r\n        legend_freq[i1] = str(i) + ' MHz'\r\n        i1 += 1\r\n    i1 = 0\r\n    for i in time_spect_mask:\r\n        legend_time[i1] = str(i) + ' sec'\r\n        i1 += 1\r\n\r\n    return legend_time, legend_freq\r\n\r\n\r\ndef form_spectr_sp1(spectr_extr, freq_spect_mask_in=freq_spect_mask, time_spect_mask_in=time_spect_mask):\r\n    \"\"\" Возвращает s_freq - срезы частотного спектра в моменты времени time_spect_mask и s_time - сканы Солнца\r\n    по времени на частотах freq_spect_mask с заданным разрешением по времени и частоте\r\n\r\n    \"\"\"\r\n    ind_spec = []\r\n    ind_time = []\r\n    N_col = np.shape(spectr_extr)[1]\r\n    s_freq = np.zeros((len(time_spect_mask_in), N_col // kf))\r\n    s_time = np.zeros((N_row // kt, len(freq_spect_mask_in)))\r\n    j = 0\r\n    for f in freq_spect_mask_in:\r\n        if band_size_init == 'half':\r\n            ind1 = (f - (N_Nyq - 1) * 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\r\n        elif band_size_init == 'whole':\r\n            ind1 = (f - 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\r\n        ind = int(ind1)\r\n        if ind > N_col - int(kf / 2) - 1:\r\n            ind = N_col - int(kf / 2) - 1\r\n        if ind < int(kf / 2):\r\n            ind = int(kf / 2)\r\n        i = 0\r\n        while kt * (i + 1) < N_row:\r\n            if kf == 1:\r\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind])\r\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind] > 100).sum()\r\n                if n_mesh == 0:\r\n                    s_time[i, j] = 2\r\n                else:\r\n                    s_time[i, j] /= n_mesh\r\n            else:\r\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)])\r\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)] > 100).sum()\r\n                if n_mesh == 0:\r\n                    s_time[i, j] = 2\r\n                else:\r\n                    s_time[i, j] /= n_mesh\r\n            i += 1\r\n        ind_spec.append(ind)\r\n        j += 1\r\n    i = 0\r\n    for t in time_spect_mask_in:\r\n        ind = int(t // delta_t)\r\n        if ind > N_row - kt / 2 - 1:\r\n            ind = N_row - int(kt / 2) - 1\r\n        if ind < (kt / 2):\r\n            ind = int(kt / 2)\r\n        j = 0\r\n        while (j + 1) * kf < N_col:\r\n            if kt == 1:\r\n                s_freq[i, j] = np.sum(spectr_extr[ind, j * kf:(j + 1) * kf])\r\n                n_mesh = (spectr_extr[ind, j * kf:(j + 1) * kf] > 10).sum()\r\n                if n_mesh == 0:\r\n                    s_freq[i, j] = 2\r\n                else:\r\n                    s_freq[i, j] /= n_mesh\r\n            else:\r\n                s_freq[i, j] = np.sum(spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf])\r\n                n_mesh = (spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf] > 10).sum()\r\n                if n_mesh == 0:\r\n                    s_freq[i, j] = 2\r\n                else:\r\n                    s_freq[i, j] /= n_mesh\r\n\r\n            j += 1\r\n        ind_time.append(ind)\r\n        i += 1\r\n    s_time = s_time.transpose()\r\n    return s_freq * (2 ** shift), s_time * (2 ** shift)\r\n\r\n\r\ndef spectr_construction(Spectr, kf, kt):\r\n    ''' Функция формирует спектр принятого сигнала с требуемым разрешением по частоте и времени. Максимальное\r\n    разрешение отсчетов по времени 8192 мкс и по частоте 7,8125 МГц. Путем суммирования и усреднерия по kt*kf\r\n    отсчетам разрешение по частоте и по времени в исходном спектре Spectr уменьшается в kf и kt раз,\r\n    соответственно. Преобразованный спектр возвращается как S1. Для трехмерного изображения\r\n    '''\r\n\r\n    N_col1 = N_col // kf\r\n    N_row1 = N_row // kt\r\n    S1 = np.zeros((N_row1, N_col1))\r\n\r\n    for i in range(N_row1):\r\n        for j in range(N_col1):\r\n            try:\r\n                S1[i, j] = np.sum(Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf])\r\n                N_mesh = (Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf] > 10).sum()\r\n                if N_mesh == 0:\r\n                    S1[i, j] = 2\r\n                else:\r\n                    S1[i, j] = S1[i, j] / N_mesh\r\n                if S1[i, j] == 0:\r\n                    S1[i, j] = 2\r\n                # if (j > 3) & (S1[i, j] > 1.5 * np.sum(S1[i, j-3:j])//3):\r\n                #     S1[i, j] = np.sum(S1[i, j-3:j])//3\r\n                if robust_filter == 'y':\r\n                    a = param_robust_filter\r\n                    if (i > 3) & (S1[i, j] < 1 / a * np.sum(S1[i - 3:i - 1, j]) // 2):\r\n                        S1[i, j] = np.sum(S1[i - 1, j])\r\n                    if (i > 3) & (S1[i, j] > a * np.sum(S1[i - 3:i - 1, j]) // 2):\r\n                        # print(S1[i - 3:i+1, j])\r\n                        S1[i, j] = np.sum(S1[i - 1, j])\r\n                        # print(S1[i, j])\r\n                        pass\r\n\r\n            except IndexError as allert_message:\r\n                print(allert_message, 'ind i = ', i, 'ind j = ', j)\r\n                pass\r\n            except ValueError as value_message:\r\n                print(value_message, 'ind i = ', i, 'ind j = ', j)\r\n                pass\r\n\r\n    return S1  # // kt // kf\r\n\r\n\r\ndef path_to_fig():\r\n    \"\"\" Создает директорию для рисунков обрабатываемого наблюдения, если она до этого не была создана,\r\n    название директории  совпадает с названием исходного файла данных наблюдения\r\n    \"\"\"\r\n    if not os.path.isdir(Path(file_path_data, current_data_file)):\r\n        os.mkdir(Path(file_path_data, current_data_file))\r\n    return\r\n\r\n\r\ndef preparing_data():\r\n    \"\"\" Функция в зависимости от вида данных (полная полоса 1-3 ГГц, половинная полоса 1-2 или 2-3 ГГц,\r\n    с двумя поляризациями или одной) выдает данные для построения графиков\"\"\"\r\n\r\n    # Для полосы 1-3 ГГц и двух возможных поляризаций выдает по два спектра (1-2 и 2-3 ГГц) для каждой поляризации.\r\n    # Если поляризация не задействована, то соответствующие спектры - пустые. Спектр 1-2 ГГц - в обратном порядке\r\n    if not (os.path.isfile(Path(file_path_data, current_data_file + '_spectrum.npy')) or os.path.isfile(Path(file_path_data, current_data_file + '_left1.npy'))):\r\n        if num_of_polar == 2 and band_size_init == 'whole':\r\n            spectrum, n_aver, measure_kind, band_size, polar = extract_whole_band()\r\n        if num_of_polar == 2 and band_size_init == 'half':\r\n            spectrum, n_aver = extract_two_polar()\r\n    else:\r\n        spectrum = np.load(Path(file_path_data, current_data_file + '_spectrum.npy'), allow_pickle=True)\r\n        with open(Path(file_path_data, current_data_file + '_head.bin'), 'rb') as inp:\r\n            head = pickle.load(inp)\r\n            n_aver = head['n_aver']\r\n            band_size = head['band_size']\r\n            polar = head['polar']\r\n            # n_aver = head['n_aver']\r\n\r\n        # Разделяем составляющие  записи в полной полосе и с возможными двумя поляризациями,\r\n        # одновременно понижая разрядность данных, меняя их тип с int64 до int32 и уменьшая\r\n        # занимаемую ими память\r\n    if num_of_polar == 2 and band_size == 'whole':\r\n        # if np.size(spectrum[0]) > 1:\r\n        #     spectrum_left1 = (spectrum[0] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_left1 = spectrum[0]\r\n        # if np.size(spectrum[1]) > 1:\r\n        #     spectrum_left2 = (spectrum[1] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_left2 = spectrum[1]\r\n        # if np.size(spectrum[2]) > 1:\r\n        #     spectrum_right1 = (spectrum[2] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_right1 = spectrum[2]\r\n        # if np.size(spectrum[3]) > 1:\r\n        #     spectrum_right2 = (spectrum[3] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_right2 = spectrum[3]\r\n    # Выдает спектры для левой и правой поляризаций шириной по 1 ГГц. При нумерации спектров учитывается\r\n    # значение зоны Найквиста. С индексом \"1\" - 1-2 ГГц, с индексом \"2\" - 2-3 ГГц, как и для случая выше.\r\n    # На выходе формально все 4 спектра, но для незадействованной полосы они пустые\r\n    elif num_of_polar == 2 and band_size == 'half':\r\n        if N_Nyq == 2:\r\n            spectrum_left1 = spectrum[0]\r\n            spectrum_right1 = spectrum[1]\r\n            spectrum_left2 = []\r\n            spectrum_right2 = []\r\n        else:\r\n            spectrum_left2 = spectrum[0]\r\n            spectrum_right2 = spectrum[1]\r\n            spectrum_left1 = []\r\n            spectrum_right1 = []\r\n    pass\r\n\r\n    return spectrum_left1, spectrum_left2, spectrum_right1, spectrum_right2, int(n_aver), band_size, polar\r\n\r\n\r\ndef unite_spectrum(spec):\r\n    spec1 = spec[0]\r\n    spec2 = spec[1]\r\n    spec3 = spec[2]\r\n    spec4 = spec[3]\r\n    ind = []\r\n    if np.size(spec1) and np.size(spec2):\r\n        n_row = np.min([np.shape(spec1)[0], np.shape(spec2)[0]])\r\n        spec1 = spec1[:n_row]\r\n        spec2 = spec2[:n_row]\r\n        spec_left = np.hstack((spec1, spec2))\r\n        ind.append('left_whole')\r\n    elif np.size(spec1):\r\n        spec_left = spec1\r\n        ind.append('left_half1')\r\n    elif np.size(spec2):\r\n        spec_left = spec2\r\n        ind.append('left_half2')\r\n    else:\r\n        spec_left = []\r\n    if np.size(spec3) and np.size(spec4):\r\n        n_row = np.min([np.shape(spec3)[0], np.shape(spec4)[0]])\r\n        spec3 = spec3[:n_row]\r\n        spec4 = spec4[:n_row]\r\n        spec_right = np.hstack((spec3, spec4))\r\n        ind.append('right_whole')\r\n    elif np.size(spec3):\r\n        spec_right = spec3\r\n        ind.append('right_half1')\r\n    elif np.size(spec4):\r\n        spec_right = spec4\r\n        ind.append('right_half2')\r\n    else:\r\n        spec_right = []\r\n    if np.size(spec_left) and np.size(spec_right):\r\n        n_row1 = np.min([np.shape(spec_left)[0], np.shape(spec_right)[0]])\r\n        spec_left = spec_left[:n_row1]\r\n        spec_right = spec_right[:n_row1]\r\n        united_spec = pd.Series([spec_left, spec_right], ind)\r\n    elif np.size(spec_left):\r\n        united_spec = pd.Series([spec_left], ind)\r\n    else:\r\n        united_spec = pd.Series([spec_right], ind)\r\n\r\n    return united_spec\r\n\r\n\r\n# Чтение с диска, если спектры ранее извлекались,\r\n# или извлечение спектров из исходных записей\r\nspectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2, n_aver, band_size, polar = \\\r\n    preparing_data()\r\naver_param = 2 ** (6 - n_aver)\r\nkf = int(freq_res / delta_f * aver_param)   # Установка разрешения по частоте в единицах максимального разрешения для\r\n# данного наблюдения delta_f/aver_param, где delta_f = 7.8125 МГц\r\nwith open(Path(file_path_data, current_data_file + '_head.bin'), 'rb') as inp:\r\n    head = pickle.load(inp)\r\n\r\n# Выравнивание спектров по результатам шумовых измерений АЧХ\r\nif align == 'y':\r\n    path_output = Path(folder_align_path, align_file_name)\r\n    spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2 = \\\r\n        align_spectrum(spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2, head, path_output)\r\n\r\n# Приведение порядка следования отсчетов по частоте к нормальному\r\nif np.size(spectr_extr_left1):\r\n    N_row = np.shape(spectr_extr_left1)[0]\r\n    for i in range(N_row):\r\n        spectr_extr_left1[i][0:] = spectr_extr_left1[i][-1::-1]\r\nif np.size(spectr_extr_right1):\r\n    N_row = np.shape(spectr_extr_right1)[0]\r\n    for i in range(N_row):\r\n        spectr_extr_right1[i][0:] = spectr_extr_right1[i][-1::-1]\r\n\r\nspectrum = pd.Series([spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2])\r\n\r\nunited_spectrum = unite_spectrum(spectrum)\r\nser_ind = united_spectrum.index\r\nif len(ser_ind) == 2:\r\n    spectrum_extr = united_spectrum[0] + united_spectrum[1]\r\nelse:\r\n    spectrum_extr = united_spectrum[0]\r\n\r\n# if noise_calibr == 'y':\r\n#     spectr_time = calibration(t_cal, spectr_time)\r\n\r\n# # ***********************************************\r\n# # ***        Графический вывод данных        ****\r\n# # ***********************************************\r\n\r\n# Динамическая маска (зависит от длины записи во времени)\r\nt_spect = N_row * delta_t\r\ntime_spect_mask = [(lambda i: (t_spect * (i + 0.05)) // 7)(i) for i in range(7)]\r\ntime_spect_mask = [1, 2, 7, 8, 9, 17, 18]\r\n# if band_size == 'whole':\r\n#   freq_spect_mask = []\r\n\r\n# Формирование спектров и сканов по маскам freq_spect_mask и time_spect_mask\r\nspectr_freq, spectr_time = form_spectr_sp1(spectrum_extr, freq_spect_mask, time_spect_mask)\r\n# np.save(file_name0 + '_spectr', spectr_time)\r\n# Формирование строк-аргументов по времени и частоте и легенды\r\nN_col = np.shape(spectrum_extr)[1]\r\nif band_size_init == 'half':\r\n    freq = np.linspace(1000 * (N_Nyq - 1) + 3.9063 / aver_param * kf, 1000 * N_Nyq - 3.9063 / aver_param * kf,\r\n                       N_col // kf)\r\nelif band_size_init == 'whole':\r\n    freq = np.linspace(1000 + 3.9063 / aver_param * kf, 3000 - 3.9063 / aver_param * kf, N_col // kf)\r\ntimeS = np.linspace(0, delta_t * N_row, N_row // kt)\r\n\r\nline_legend_time, line_legend_freq = line_legend(freq_spect_mask[:10])\r\ninfo_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\r\n            ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\r\n            ('polarisation ' + polar), 'align: ' + align]\r\npath_to_fig()\r\n\r\nif parameters['output_picture_mode'] == 'yes':\r\n    fp.fig_plot(spectr_freq, 0, freq, 1, info_txt, Path(file_path_data, current_data_file), head, line_legend_time)\r\n    fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, Path(file_path_data, current_data_file), head, line_legend_freq)\r\n# fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, Path(file_path_data, current_data_file), head, line_legend_freq)\r\n# *********************************************************\r\n# ***            Многооконный вывод данных             ****\r\n# *********************************************************\r\nif parameters['output_picture_mode'] == 'no':\r\n    fp.fig_multi_axes(spectr_time, timeS, info_txt, Path(file_path_data, current_data_file),\r\n                      freq_spect_mask, head)\r\n\r\n# *********************************************************\r\n# ***        Вывод данных двумерный и трехмерный       ****\r\n# *********************************************************\r\n# Укрупнение  разрешения по частоте и времени для вывода в 2d и 3d\r\nif graph_3d_perm == 'y' or contour_2d_perm == 'y':\r\n    spectr_extr1 = spectr_construction(spectrum_extr, kf, kt)\r\n# Информация о временном и частотном резрешениях\r\ninfo_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\r\n            ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\r\n            ('polarisation ' + polar)]\r\npath_to_fig()\r\n\r\nif graph_3d_perm == 'y':\r\n    fp.graph_3d(freq, timeS, spectr_extr1, 0, current_data_file, head)\r\nif contour_2d_perm == 'y':\r\n    fp.graph_contour_2d(freq, timeS, spectr_extr1, 0)\r\n\r\n# if align == 'y':\r\n#     align_coeff1 = align_func1(spectr_freq[1, :], 'y', aver_param)\r\n#     spectr_extr = spectr_extr * align_coeff1\r\n\r\n# if graph_3d_perm == 'y':\r\n#     graph_3d(freq, timeS[n_start_flame:n_stop_flame], spectr_extr1[n_start_flame:n_stop_flame, :], 0)\r\n# fp.fig_multi_axes(spectr_time[:10, n_start_flame:n_stop_flame], timeS[n_start_flame:n_stop_flame],\r\n#                   info_txt, file_name0, freq_spect_mask[:10])\r\n\r\n\r\nstop = datetime.now()\r\nprint('\\n Total time = ', stop - start)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extract_from_binary.py b/extract_from_binary.py
--- a/extract_from_binary.py	(revision f55d514b029802551262170933084570e518def9)
+++ b/extract_from_binary.py	(date 1636375676056)
@@ -54,7 +54,7 @@
 align = 'y'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ ('y' / 'n')
 
 noise_calibr = 'n'
-graph_3d_perm = 'y'
+graph_3d_perm = 'n'
 contour_2d_perm = 'n'
 
 if N_Nyq == 3:
