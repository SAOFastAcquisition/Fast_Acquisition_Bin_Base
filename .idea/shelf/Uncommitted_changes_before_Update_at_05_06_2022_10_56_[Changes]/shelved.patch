Index: Data_treatment/data_visualisation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport os\r\nimport sys\r\nimport pandas as pd\r\nimport pickle\r\nimport json as jsn\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nfrom Supporting_func import Fig_plot as fp, align_spectrum, path_to_data\r\n# from Supporting_func import align_spectrum, path_to_data\r\nfrom Interface import main\r\nfrom Polyphase import low_freq_noise_spectrum, plot_low_freq_spec\r\nfrom Interface.window_handler import exec_app\r\nfrom Polyphase.cic_filter import signal_filtering\r\nfrom test_statistic import low_noise_spectra_base\r\nfrom polys3d_demo import poly_graph3d\r\n\r\ncurrent_dir = Path.cwd()\r\nhome_dir = Path.home()\r\n\r\nsys.path.insert(0, Path(current_dir, 'Supporting_func'))\r\nsys.path.insert(0, Path(current_dir, 'Interface'))\r\nsys.path.insert(0, Path(current_dir, 'Polyphase'))\r\nstart = datetime.now()\r\n\r\nfreq_spect_mask = [1171, 1380, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920]\r\ntime_spect_mask = [47, 84.4, 104, 133, 133.05, 177.02, 177.38]\r\n\r\n\r\ndef parts_to_numpy(list_arr, len_list):\r\n    \"\"\" Функция превращает список в массив numpy.\r\n    Разбивает файл на меньшие части и обрабатывает их поотдельности. По ходу завершинея обработки частей\r\n    происходит объединение обработанных частей.\"\"\"\r\n    n = int(len_list // 1e5)\r\n    k = int(len_list % 1e5)\r\n    numpy_arr = []\r\n    for i in range(n + 1):\r\n        if i == n:\r\n            auxiliary = list_arr[int(i * 1e5):int(i * 1e5 + k)]\r\n            auxiliary = np.array(auxiliary, dtype='int64')\r\n        else:\r\n            auxiliary = list_arr[int(i * 1e5):int((i + 1) * 1e5)]\r\n            auxiliary = np.array(auxiliary, dtype='int64')\r\n        l = np.size(numpy_arr)\r\n        if l:\r\n            numpy_arr = np.vstack([numpy_arr, auxiliary])\r\n        else:\r\n            numpy_arr = auxiliary\r\n\r\n    return numpy_arr\r\n\r\n\r\ndef cut_spectrum(spectrum, n_aver):\r\n    spectrum.pop(-1)\r\n    n_frame_last = spectrum[-1][0]\r\n    rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n    if rest:\r\n        for k in range(rest):\r\n            spectrum.pop(-1)\r\n    print(n_frame_last, spectrum[-1][0])\r\n    return spectrum\r\n\r\n\r\ndef line_legend(freq_mask):\r\n    N_col_leg = len(freq_mask)\r\n    N_row_leg = len(time_spect_mask)\r\n    legend_freq = [0] * N_col_leg\r\n    legend_time = [0] * N_row_leg\r\n    i1 = 0\r\n    for i in freq_mask:\r\n        legend_freq[i1] = str(i) + ' MHz'\r\n        i1 += 1\r\n    i1 = 0\r\n    for i in time_spect_mask:\r\n        legend_time[i1] = str(i) + ' sec'\r\n        i1 += 1\r\n\r\n    return legend_time, legend_freq\r\n\r\n\r\ndef form_spectr_sp1(spectr_extr, freq_spect_mask_in=freq_spect_mask, time_spect_mask_in=time_spect_mask):\r\n    \"\"\" Возвращает s_freq - срезы частотного спектра в моменты времени time_spect_mask и s_time - сканы Солнца\r\n    по времени на частотах freq_spect_mask с заданным разрешением по времени и частоте\r\n\r\n    \"\"\"\r\n    ind_spec = []\r\n    ind_time = []\r\n    t_ng = 1\r\n    N_col = np.shape(spectr_extr)[1]\r\n    s_freq = np.zeros((len(time_spect_mask_in), N_col // kf))\r\n    s_time = np.zeros((N_row // kt, len(freq_spect_mask_in)))\r\n    j = 0\r\n    for f in freq_spect_mask_in:\r\n        if band_size_init == 'half':\r\n            ind1 = (f - (N_Nyq - 1) * 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\r\n        elif band_size_init == 'whole':\r\n            ind1 = (f - 1000 - delta_f / aver_param / 2) // (delta_f / aver_param)\r\n        ind = int(ind1)\r\n        if ind > N_col - int(kf / 2) - 1:\r\n            ind = N_col - int(kf / 2) - 1\r\n        if ind < int(kf / 2):\r\n            ind = int(kf / 2)\r\n        i = 0\r\n        while kt * (i + 1) < N_row:\r\n            if kf == 1:\r\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind])\r\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind] > 100).sum()\r\n                if n_mesh == 0:\r\n                    s_time[i, j] = 2\r\n                else:\r\n                    s_time[i, j] /= n_mesh\r\n            else:\r\n                s_time[i, j] = np.sum(spectr_extr[i * kt:(i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)])\r\n                n_mesh = (spectr_extr[i * kt: (i + 1) * kt, ind - int(kf / 2):ind + int(kf / 2)] > 100).sum()\r\n                if n_mesh == 0:\r\n                    s_time[i, j] = 2\r\n                else:\r\n                    s_time[i, j] /= n_mesh\r\n            i += 1\r\n        ind_spec.append(ind)\r\n        j += 1\r\n    i = 0\r\n    for t in time_spect_mask_in:\r\n        ind = int(t // delta_t)\r\n        if ind > N_row - kt / 2 - 1:\r\n            ind = N_row - int(kt / 2) - 1\r\n        if ind < (kt / 2):\r\n            ind = int(kt / 2)\r\n        j = 0\r\n        while (j + 1) * kf < N_col:\r\n            if kt == 1:\r\n                s_freq[i, j] = np.sum(spectr_extr[ind, j * kf:(j + 1) * kf])\r\n                n_mesh = (spectr_extr[ind, j * kf:(j + 1) * kf] > 10).sum()\r\n                if n_mesh == 0:\r\n                    s_freq[i, j] = 2\r\n                else:\r\n                    s_freq[i, j] /= n_mesh\r\n            else:\r\n                s_freq[i, j] = np.sum(spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf])\r\n                n_mesh = (spectr_extr[ind - int(kt / 2):ind + int(kt / 2), j * kf:(j + 1) * kf] > 10).sum()\r\n                if n_mesh == 0:\r\n                    s_freq[i, j] = 2\r\n                else:\r\n                    s_freq[i, j] /= n_mesh\r\n\r\n            j += 1\r\n        ind_time.append(ind)\r\n        i += 1\r\n    s_time = s_time.transpose()\r\n    if head['att3'] == 0:\r\n        a = 5.27e8\r\n    elif head['att3'] == 5:\r\n        a = 6.21e8\r\n    else:\r\n        a = 5.8e8\r\n    a = 1\r\n    return s_freq * (2 ** shift) * t_ng / a, s_time * (2 ** shift) * t_ng / a\r\n\r\n\r\ndef spectr_construction(Spectr, kf, kt):\r\n    ''' Функция формирует спектр принятого сигнала с требуемым разрешением по частоте и времени. Максимальное\r\n    разрешение отсчетов по времени 8192 мкс и по частоте 7,8125 МГц. Путем суммирования и усреднерия по kt*kf\r\n    отсчетам разрешение по частоте и по времени в исходном спектре Spectr уменьшается в kf и kt раз,\r\n    соответственно. Преобразованный спектр возвращается как S1. Для трехмерного изображения\r\n    '''\r\n\r\n    N_col1 = N_col // kf\r\n    N_row1 = N_row // kt\r\n    S1 = np.zeros((N_row1, N_col1))\r\n\r\n    for i in range(N_row1):\r\n        for j in range(N_col1):\r\n            try:\r\n                S1[i, j] = np.sum(Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf])\r\n                N_mesh = (Spectr[i * kt: (i + 1) * kt, j * kf: (j + 1) * kf] > 10).sum()\r\n                if N_mesh == 0:\r\n                    S1[i, j] = 2\r\n                else:\r\n                    S1[i, j] = S1[i, j] / N_mesh\r\n                if S1[i, j] == 0:\r\n                    S1[i, j] = 2\r\n                # if (j > 3) & (S1[i, j] > 1.5 * np.sum(S1[i, j-3:j])//3):\r\n                #     S1[i, j] = np.sum(S1[i, j-3:j])//3\r\n                if robust_filter == 'y':\r\n                    a = param_robust_filter\r\n                    if (i > 3) & (S1[i, j] < 1 / a * np.sum(S1[i - 3:i - 1, j]) // 2):\r\n                        S1[i, j] = np.sum(S1[i - 1, j])\r\n                    if (i > 3) & (S1[i, j] > a * np.sum(S1[i - 3:i - 1, j]) // 2):\r\n                        # print(S1[i - 3:i+1, j])\r\n                        S1[i, j] = np.sum(S1[i - 1, j])\r\n                        # print(S1[i, j])\r\n                        pass\r\n\r\n            except IndexError as allert_message:\r\n                print(allert_message, 'ind i = ', i, 'ind j = ', j)\r\n                pass\r\n            except ValueError as value_message:\r\n                print(value_message, 'ind i = ', i, 'ind j = ', j)\r\n                pass\r\n\r\n    return S1  # // kt // kf\r\n\r\n\r\ndef path_to_fig(_path):\r\n    \"\"\" Создает директорию для рисунков обрабатываемого наблюдения, если она до этого не была создана,\r\n    название директории  совпадает с названием исходного файла данных наблюдения\r\n    \"\"\"\r\n    if not os.path.isdir(_path):\r\n        os.mkdir(_path)\r\n    return\r\n\r\n\r\ndef preparing_data():\r\n    \"\"\" Функция в зависимости от вида данных (полная полоса 1-3 ГГц, половинная полоса 1-2 или 2-3 ГГц,\r\n    с двумя поляризациями или одной) выдает данные для построения графиков\"\"\"\r\n\r\n    # Для полосы 1-3 ГГц и двух возможных поляризаций выдает по два спектра (1-2 и 2-3 ГГц) для каждой поляризации.\r\n    # Если поляризация не задействована, то соответствующие спектры - пустые. Спектр 1-2 ГГц - в обратном порядке\r\n    _path1 = Path(converted_data_file_path, current_primary_file + '_spectrum.npy')\r\n    spectrum = np.load(_path1, allow_pickle=True)\r\n    with open(Path(converted_data_file_path, current_primary_file + '_head.bin'), 'rb') as inp:\r\n        head = pickle.load(inp)\r\n    n_aver = head['n_aver']\r\n    band_size = head['band_size']\r\n    polar = head['polar']\r\n    # n_aver = head['n_aver']\r\n\r\n    # Разделяем составляющие  записи в полной полосе и с возможными двумя поляризациями,\r\n    # одновременно понижая разрядность данных, меняя их тип с int64 до int32 и уменьшая\r\n    # занимаемую ими память\r\n    if num_of_polar == 2 and band_size == 'whole':\r\n        # if np.size(spectrum[0]) > 1:\r\n        #     spectrum_left1 = (spectrum[0] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_left1 = spectrum[0]\r\n        # if np.size(spectrum[1]) > 1:\r\n        #     spectrum_left2 = (spectrum[1] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_left2 = spectrum[1]\r\n        # if np.size(spectrum[2]) > 1:\r\n        #     spectrum_right1 = (spectrum[2] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_right1 = spectrum[2]\r\n        # if np.size(spectrum[3]) > 1:\r\n        #     spectrum_right2 = (spectrum[3] / 1000).astype(np.int32)\r\n        # else:\r\n        spectrum_right2 = spectrum[3]\r\n    # Выдает спектры для левой и правой поляризаций шириной по 1 ГГц. При нумерации спектров учитывается\r\n    # значение зоны Найквиста. С индексом \"1\" - 1-2 ГГц, с индексом \"2\" - 2-3 ГГц, как и для случая выше.\r\n    # На выходе формально все 4 спектра, но для незадействованной полосы они пустые\r\n    elif num_of_polar == 2 and band_size == 'half':\r\n        if N_Nyq == 2:\r\n            spectrum_left1 = spectrum[0]\r\n            spectrum_right1 = spectrum[1]\r\n            spectrum_left2 = []\r\n            spectrum_right2 = []\r\n        else:\r\n            spectrum_left2 = spectrum[0]\r\n            spectrum_right2 = spectrum[1]\r\n            spectrum_left1 = []\r\n            spectrum_right1 = []\r\n    pass\r\n\r\n    return spectrum_left1, spectrum_left2, spectrum_right1, spectrum_right2, int(n_aver), band_size, polar\r\n\r\n\r\ndef unite_spectrum(spec):\r\n    spec1 = spec[0]\r\n    spec2 = spec[1]\r\n    spec3 = spec[2]\r\n    spec4 = spec[3]\r\n    ind = []\r\n    if np.size(spec1) and np.size(spec2):\r\n        n_row = np.min([np.shape(spec1)[0], np.shape(spec2)[0]])\r\n        spec1 = spec1[:n_row]\r\n        spec2 = spec2[:n_row]\r\n        spec_left = np.hstack((spec1, spec2))\r\n        ind.append('left_whole')\r\n    elif np.size(spec1):\r\n        spec_left = spec1\r\n        ind.append('left_half1')\r\n    elif np.size(spec2):\r\n        spec_left = spec2\r\n        ind.append('left_half2')\r\n    else:\r\n        spec_left = []\r\n    if np.size(spec3) and np.size(spec4):\r\n        n_row = np.min([np.shape(spec3)[0], np.shape(spec4)[0]])\r\n        spec3 = spec3[:n_row]\r\n        spec4 = spec4[:n_row]\r\n        spec_right = np.hstack((spec3, spec4))\r\n        ind.append('right_whole')\r\n    elif np.size(spec3):\r\n        spec_right = spec3\r\n        ind.append('right_half1')\r\n    elif np.size(spec4):\r\n        spec_right = spec4\r\n        ind.append('right_half2')\r\n    else:\r\n        spec_right = []\r\n    if np.size(spec_left) and np.size(spec_right):\r\n        n_row1 = np.min([np.shape(spec_left)[0], np.shape(spec_right)[0]])\r\n        spec_left = spec_left[:n_row1]\r\n        spec_right = spec_right[:n_row1]\r\n        united_spec = pd.Series([spec_left, spec_right], ind)\r\n    elif np.size(spec_left):\r\n        united_spec = pd.Series([spec_left], ind)\r\n    else:\r\n        united_spec = pd.Series([spec_right], ind)\r\n    print('Spectra are united')\r\n    return united_spec\r\n\r\n\r\ndef freq_mask(_i):\r\n    _n1 = 1\r\n    _n2 = 5\r\n    _freq_mask = [\r\n        [1350],                                                               # [0]\r\n        [2060, 2220, 2300, 2500, 2560, 2700, 2800, 2880, 2980],               # [1]\r\n        [1080, 1140, 1360, 1420, 1620, 1780, 1980],                           # [2]\r\n        [1000 * _n1 + 100 * _n2 + 10 * i for i in range(10)],                 # [3]\r\n        [1050, 1465, 1535, 1600, 1700, 2265, 2550, 2700, 2800, 2920],         # [4]\r\n        [1230, 1560, 2300, 2910],                                                               # [5]\r\n        [1140, 1420, 1480, 2460, 2500, 2780],   # for Crab '2021-06-28_03+14' # [6]\r\n        [1220, 1540, 1980, 2060, 2500, 2780],   # for Crab '2021-06-28_04+12' # [7]\r\n        [1171, 1380, 1465, 1600, 1700, 2265, 2530, 2720, 2800, 2920]    # [8]\r\n    ]\r\n    return _freq_mask[_i]\r\n\r\n\r\ndef data_poly3d_prep(_spectrum_extr):\r\n    _k, _m = np.shape(_spectrum_extr)\r\n    freq_mask_poly = [1100, 1200, 1700, 1800, 2800, 2900]   # Маска для выбора спектров из трех диапазонов частот\r\n    freq_mask_singles = [1100, 1200, 1300, 1700, 1780, 2080, 2300, 2500, 2720, 2800, 2920]  # Маска для одиночных частот\r\n    mask_poly = 'y'\r\n    _data_poly3d = []\r\n    num_mask = []\r\n\r\n    if mask_poly == 'y':\r\n        i = 0\r\n        _n = [0] * 6\r\n        for s in freq_mask_poly:\r\n            _n[i] = int((s - 1000) / 2000 * _m)\r\n            if i % 2 == 1:\r\n                if len(num_mask) == 0:\r\n                    num_mask = [n for n in range(_n[i - 1], _n[i] + 1)]\r\n                else:\r\n                    num_mask = np.hstack((num_mask, [n for n in range(_n[i - 1], _n[i] + 1)]))\r\n            i += 1\r\n    else:\r\n        num_mask = [int((s - 1000) / 2000 * _m) for s in freq_mask_singles]\r\n\r\n    _data_poly3d = _spectrum_extr[:, num_mask]\r\n    _freq_mask = freq[num_mask]\r\n\r\n    return _data_poly3d, _freq_mask\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n    # parameters = main()\r\n    # current_data_file = parameters['file_name']      # Имя файла с исходными текущими данными без расширения\r\n    # current_data_dir = parameters['file_folder']          # Папка с текущими данными\r\n    # freq_res = parameters['freq_res']  # Установка разрешения по частоте в МГц\r\n    # kt = parameters['time_res'] // 8  # Установка разрешения по времени в единицах минимального разрешения\r\n    # 8.1925e-3 сек\r\n    # output_picture_mode = parameters['output_picture_mode'] == 'yes'\r\n    align_file_name = 'Align_coeff.bin'         # Имя файла с текущими коэффициентами выравнивания АЧХ\r\n    # current_catalog = r'2021/Results'           # Текущий каталог (за определенный период, здесь - год)\r\n\r\n    current_data_dir = '2022'\r\n    primary_data_dir = 'Primary_data'           # Каталог исходных данных (за определенный период, здесь - год)\r\n    converted_data_dir = 'Converted_data'       # Каталог для записи результатов конвертации данных и заголовков\r\n    data_treatment_dir = 'Data_treatment'       # Каталог для записи результатов обработки, рисунков\r\n\r\n    current_primary_dir = '2022_03_28moon'\r\n    current_converted_dir = current_primary_dir + '_conv'\r\n    current_converted_path = Path(converted_data_dir, current_converted_dir)\r\n    current_treatment_dir = current_primary_dir + '_treat'\r\n    current_treatment_path = Path(data_treatment_dir, current_treatment_dir)\r\n\r\n    current_primary_file = '2022-03-28_02+24'\r\n\r\n    converted_data_file_path, head_path = path_to_data(current_data_dir, current_converted_path)\r\n    data_treatment_file_path, head_path = path_to_data(current_data_dir, current_treatment_path)\r\n\r\n    folder_align_path = Path(head_path, 'Alignment')\r\n    date = current_primary_file[0:10]\r\n\r\n    # !!!! ******************************************* !!!!\r\n    # ****** Блок исходных параметров для обработки *******\r\n\r\n    freq_res = 32  # Установка разрешения по частоте в МГц\r\n    kt = 30  # Установка разрешения по времени в единицах минимального разрешения 8.1925e-3 сек\r\n    delta_t = 8.3886e-3\r\n    delta_f = 7.8125\r\n    N_Nyq = 3\r\n    att_val = [i * 0.5 for i in range(64)]\r\n    att_dict = {s: 10 ** (s / 10) for s in att_val}\r\n    freq_spect_mask = freq_mask(3)\r\n    # *****************************************************\r\n\r\n    band_size_init = 'whole'\r\n    num_of_polar = 2\r\n    # band_size = 'whole'   Параметр 'whole' означает работу в диапазоне 1-3 ГГц, 'half' - диапазон 1-2 или 2-3 ГГц\r\n    # polar = 'both'        Принимает значения поляризаций: 'both', 'left', 'right'\r\n    # *****************************************************\r\n    output_picture_mode = 'y'\r\n    align = 'y'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ: 'y' / 'n'\r\n    noise_calibr = 'n'\r\n    save_data = 'n'     # Сохранение сканов в формате *.npy: 'y' / 'n'\r\n    lf_filter = 'y'     # Применение НЧ фильтра для сглаживания сканов (скользящее среднее и др.): 'y' / 'n'\r\n    low_noise_spectrum = 'n'    # Вывод графика НЧ спектра шумовой дорожки: 'y' / 'n'\r\n    robust_filter = 'n'\r\n    graph_3d_perm = 'n'\r\n    contour_2d_perm = 'n'\r\n    poly3d_perm = 'n'\r\n\r\n    # *****************************************************\r\n    # Чтение с диска, если спектры ранее извлекались,\r\n    # или извлечение спектров из исходных записей\r\n    spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2, n_aver, band_size, polar = \\\r\n        preparing_data()\r\n    print('Data are prepared')\r\n    aver_param = 2 ** (6 - n_aver)\r\n    kf = int(freq_res / delta_f * aver_param)   # Установка разрешения по частоте в единицах максимального разрешения\r\n                                                # для данного наблюдения delta_f/aver_param, где delta_f = 7.8125 МГц\r\n    with open(Path(converted_data_file_path, current_primary_file + '_head.bin'), 'rb') as inp:\r\n        head = pickle.load(inp)\r\n\r\n    # Выравнивание спектров по результатам шумовых измерений АЧХ\r\n    if align == 'y':\r\n        if head['att3'] == 5:\r\n            pos = 0\r\n        elif head['att3'] == 0:\r\n            pos = 0\r\n        else:\r\n            pos = 1\r\n        path_output = Path(folder_align_path, align_file_name)\r\n        spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2 = \\\r\n            align_spectrum(spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2,\r\n                           head, path_output, pos)\r\n        print('spectrum is aligned')\r\n\r\n    # Приведение порядка следования отсчетов по частоте к нормальному\r\n    if np.size(spectr_extr_left1):\r\n        N_row = np.shape(spectr_extr_left1)[0]\r\n        for i in range(N_row):\r\n            spectr_extr_left1[i][0:] = spectr_extr_left1[i][-1::-1]\r\n    if np.size(spectr_extr_right1):\r\n        N_row = np.shape(spectr_extr_right1)[0]\r\n        for i in range(N_row):\r\n            spectr_extr_right1[i][0:] = spectr_extr_right1[i][-1::-1]\r\n\r\n    spectrum = pd.Series([spectr_extr_left1, spectr_extr_left2, spectr_extr_right1, spectr_extr_right2])\r\n\r\n    united_spectrum = unite_spectrum(spectrum)\r\n    ser_ind = united_spectrum.index\r\n    if len(ser_ind) == 2:\r\n        spectrum_extr = united_spectrum[0] + united_spectrum[1]\r\n    else:\r\n        spectrum_extr = united_spectrum[0]\r\n\r\n    # if noise_calibr == 'y':\r\n    #     spectr_time = calibration(t_cal, spectr_time)\r\n\r\n    # # ***********************************************\r\n    # # ***        Графический вывод данных        ****\r\n    # # ***********************************************\r\n\r\n    # Динамическая маска (зависит от длины записи во времени)\r\n    t_spect = N_row * delta_t\r\n    time_spect_mask = [(lambda i: (t_spect * (i + 0.05)) // 7)(i) for i in range(7)]\r\n    # time_spect_mask = [5, 17, 31, 43, 58]\r\n    # if band_size == 'whole':\r\n    #   freq_spect_mask = []\r\n\r\n    # Формирование спектров и сканов по маскам freq_spect_mask и time_spect_mask\r\n    shift = head['shift']\r\n    spectr_freq, spectr_time = form_spectr_sp1(spectrum_extr, freq_spect_mask, time_spect_mask)\r\n    print('spectr_freq, spectr_time are formed')\r\n    # Формирование строк-аргументов по времени и частоте и легенды\r\n    N_col = np.shape(spectrum_extr)[1]\r\n    if band_size_init == 'half':\r\n        freq = np.linspace(1000 * (N_Nyq - 1) + 3.9063 / aver_param * kf, 1000 * N_Nyq - 3.9063 / aver_param * kf,\r\n                           N_col // kf)\r\n    elif band_size_init == 'whole':\r\n        freq = np.linspace(1000 + 3.9063 / aver_param * kf, 3000 - 3.9063 / aver_param * kf, N_col // kf)\r\n    timeS = np.linspace(0, delta_t * N_row, N_row // kt)\r\n\r\n    # ***************!! Вывод данных в текстовой форме !!*********************\r\n    # path_txt = str(Path(file_path_data, current_data_file, '_scan.txt'))\r\n    # print(path_txt)\r\n    # np.savetxt(path_txt, spectr_freq)\r\n    # path_txt = str(Path(file_path_data, current_data_file, 'freq.txt'))\r\n    # print(path_txt)\r\n    # np.savetxt(path_txt, freq)\r\n    # ***********************************************************************\r\n\r\n    # ************************** !!! Вывод данных !!! ***********************\r\n    line_legend_time, line_legend_freq = line_legend(freq_spect_mask[:10])\r\n    if not 'good_bound' in head:\r\n        head['good_bound'] = 0.1\r\n    info_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\r\n                ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\r\n                ('polarisation ' + polar), 'align: ' + align, 'kurtosis quality = ' + str(head['good_bound'])]\r\n    path1 = Path(data_treatment_file_path, current_primary_file)\r\n    path_to_fig(data_treatment_file_path)\r\n    path_to_fig(path1)\r\n    # ********************** Сохранение сканов в формате *.npy **************\r\n    if save_data == 'y':\r\n        np.save(path1, spectr_time)\r\n        path_mesh = Path(data_treatment_file_path, 'Meshed_Spectrum', current_primary_file + '_meshed')\r\n        path_mesh1 = Path(data_treatment_file_path, 'Meshed_Spectrum', current_primary_file + '_meshed' + '.npy')\r\n        if os.path.isfile(path_mesh1):\r\n            print('Meshed spectrum file exist')\r\n        else:\r\n            path_to_fig(Path(data_treatment_file_path, 'Meshed_Spectrum'))\r\n            spectrum_mesh = spectr_construction(spectrum_extr, kf, kt)\r\n            np.save(path_mesh, spectrum_mesh)\r\n    # ***********************************************************************\r\n    if lf_filter == 'y':\r\n        spectr_time = signal_filtering(spectr_time, 0.003)\r\n    if low_noise_spectrum == 'y':\r\n        spectrum_signal_av = low_freq_noise_spectrum(spectr_time, 32768)\r\n        if kt == 1 & kf == 1:\r\n            m, n = spectrum_signal_av.shape\r\n            f_max = 1 / delta_t / 2\r\n            f_min = f_max / n\r\n            arg = np.linspace(f_min, f_max, n)\r\n            low_noise_spectra_base(spectrum_signal_av, head, freq_spect_mask, arg, current_primary_file)\r\n        plot_low_freq_spec(spectrum_signal_av, delta_t * kt, path1, line_legend_freq)\r\n\r\n    if output_picture_mode == 'y':\r\n        # fp.fig_plot(spectr_freq, 0, freq, 1, info_txt, path1, head, line_legend_time)\r\n        fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, path1, head, line_legend_freq)\r\n\r\n    # *********************************************************\r\n    # ***            Многооконный вывод данных             ****\r\n    # *********************************************************\r\n    if output_picture_mode == 'no':\r\n        fp.fig_multi_axes(spectr_time, timeS, info_txt, Path(current_treatment_path, current_primary_file),\r\n                          freq_spect_mask, head)\r\n\r\n    # *********************************************************\r\n    # ***        Вывод данных двумерный и трехмерный       ****\r\n    # *********************************************************\r\n    # Укрупнение  разрешения по частоте и времени для вывода в 2d и 3d\r\n    if graph_3d_perm == 'y' or contour_2d_perm == 'y' or poly3d_perm == 'y':\r\n        spectr_extr1 = spectr_construction(spectrum_extr, kf, kt)\r\n    # Информация о временном и частотном резрешениях\r\n    info_txt = [('time resol = ' + str(delta_t * kt) + 'sec'),\r\n                ('freq resol = ' + str(delta_f / aver_param * kf) + 'MHz'),\r\n                ('polarisation ' + polar)]\r\n\r\n    if graph_3d_perm == 'y':\r\n        fp.graph_3d(freq, timeS, spectr_extr1, 0, current_data_file, head)\r\n    if contour_2d_perm == 'y':\r\n        fp.graph_contour_2d(freq, timeS, spectr_extr1, 0)\r\n\r\n    if poly3d_perm == 'y':\r\n        data_poly3d, freq_mask = data_poly3d_prep(spectr_extr1)\r\n        poly_graph3d(timeS, data_poly3d, freq_mask)\r\n\r\n\r\n    # if align == 'y':\r\n    #     align_coeff1 = align_func1(spectr_freq[1, :], 'y', aver_param)\r\n    #     spectr_extr = spectr_extr * align_coeff1\r\n\r\n    # if graph_3d_perm == 'y':\r\n    #     graph_3d(freq, timeS[n_start_flame:n_stop_flame], spectr_extr1[n_start_flame:n_stop_flame, :], 0)\r\n    # fp.fig_multi_axes(spectr_time[:10, n_start_flame:n_stop_flame], timeS[n_start_flame:n_stop_flame],\r\n    #                   info_txt, file_name0, freq_spect_mask[:10])\r\n\r\n\r\n    stop = datetime.now()\r\n    print('\\n Total time = ', stop - start)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Data_treatment/data_visualisation.py b/Data_treatment/data_visualisation.py
--- a/Data_treatment/data_visualisation.py	(revision 40bd91099ec0babc7b0fc3b97654ef1eb2e753fd)
+++ b/Data_treatment/data_visualisation.py	(date 1651238304964)
@@ -373,13 +373,13 @@
     converted_data_dir = 'Converted_data'       # Каталог для записи результатов конвертации данных и заголовков
     data_treatment_dir = 'Data_treatment'       # Каталог для записи результатов обработки, рисунков
 
-    current_primary_dir = '2022_03_28moon'
+    current_primary_dir = '2022_04_29sun'
     current_converted_dir = current_primary_dir + '_conv'
     current_converted_path = Path(converted_data_dir, current_converted_dir)
     current_treatment_dir = current_primary_dir + '_treat'
     current_treatment_path = Path(data_treatment_dir, current_treatment_dir)
 
-    current_primary_file = '2022-03-28_02+24'
+    current_primary_file = '2022-04-29_05+12'
 
     converted_data_file_path, head_path = path_to_data(current_data_dir, current_converted_path)
     data_treatment_file_path, head_path = path_to_data(current_data_dir, current_treatment_path)
@@ -390,14 +390,14 @@
     # !!!! ******************************************* !!!!
     # ****** Блок исходных параметров для обработки *******
 
-    freq_res = 32  # Установка разрешения по частоте в МГц
-    kt = 30  # Установка разрешения по времени в единицах минимального разрешения 8.1925e-3 сек
+    freq_res = 8  # Установка разрешения по частоте в МГц
+    kt = 2  # Установка разрешения по времени в единицах минимального разрешения 8.1925e-3 сек
     delta_t = 8.3886e-3
     delta_f = 7.8125
     N_Nyq = 3
     att_val = [i * 0.5 for i in range(64)]
     att_dict = {s: 10 ** (s / 10) for s in att_val}
-    freq_spect_mask = freq_mask(3)
+    freq_spect_mask = freq_mask(8)
     # *****************************************************
 
     band_size_init = 'whole'
@@ -406,10 +406,10 @@
     # polar = 'both'        Принимает значения поляризаций: 'both', 'left', 'right'
     # *****************************************************
     output_picture_mode = 'y'
-    align = 'y'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ: 'y' / 'n'
+    align = 'n'  # Выравнивание АЧХ усилительного тракта по калибровке от ГШ: 'y' / 'n'
     noise_calibr = 'n'
     save_data = 'n'     # Сохранение сканов в формате *.npy: 'y' / 'n'
-    lf_filter = 'y'     # Применение НЧ фильтра для сглаживания сканов (скользящее среднее и др.): 'y' / 'n'
+    lf_filter = 'n'     # Применение НЧ фильтра для сглаживания сканов (скользящее среднее и др.): 'y' / 'n'
     low_noise_spectrum = 'n'    # Вывод графика НЧ спектра шумовой дорожки: 'y' / 'n'
     robust_filter = 'n'
     graph_3d_perm = 'n'
@@ -532,7 +532,7 @@
         plot_low_freq_spec(spectrum_signal_av, delta_t * kt, path1, line_legend_freq)
 
     if output_picture_mode == 'y':
-        # fp.fig_plot(spectr_freq, 0, freq, 1, info_txt, path1, head, line_legend_time)
+        fp.fig_plot(spectr_freq, 0, freq, 1, info_txt, path1, head, line_legend_time)
         fp.fig_plot(spectr_time, 0, timeS, 0, info_txt, path1, head, line_legend_freq)
 
     # *********************************************************
Index: Data_extraction/extract_from_flow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport os\r\nimport sys\r\nimport pandas as pd\r\nimport pickle\r\nimport json as jsn\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nfrom Supporting_func import align_spectrum, path_to_data\r\n\r\ncurrent_dir = Path.cwd()\r\nhome_dir = Path.home()\r\n\r\nsys.path.insert(0, Path(current_dir, 'Supporting_func'))\r\nsys.path.insert(0, Path(current_dir, 'Interface'))\r\n\r\n\r\ndef extract():\r\n    file_name = Path(file_path_data, current_data_file + '.bin')\r\n    file_name_out = Path(file_path_data, current_data_file + '.txt')\r\n    i = 0\r\n    k = 0\r\n    spectr = []\r\n    frame = ' '\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n\r\n        f_in = open(file_name, 'rb')\r\n\r\n        while frame:\r\n\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\r\n            for k in range(129):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n\r\n                else:\r\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    spectr_frame.append(spectr_val)\r\n                    pass\r\n\r\n            spectr.append(spectr_frame)\r\n            print(i, frame_num)\r\n            i += 1\r\n\r\n        pass\r\n\r\n        spectr.pop(-1)\r\n        N = len(spectr)\r\n        n_frame_last = spectr[-1][0]\r\n        rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n        if rest:\r\n            for k in range(rest):\r\n                spectr.pop(-1)\r\n        print(n_frame_last, spectr[-1][0])\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n\r\n        spectr1 = convert_to_matrix(spectr, spectr[-1][0] + 1, n_aver)\r\n    np.savetxt(file_name_out, spectr1, header=(str(n_aver) + '-n_aver ' + str(bound_left) + '-kurt'))\r\n\r\n    return spectr1, n_aver\r\n\r\n\r\ndef extract_two_polar():\r\n    file_name = file_name0 + '.bin'\r\n    # file_name_out = file_name0 + '.txt'\r\n    # *********** Если система работает с одной поляризацией ************\r\n    if not file_name0.find('Ant2') == -1:\r\n        antenna2_0 = 1\r\n    else:\r\n        antenna2_0 = 0\r\n    # *******************************************************************\r\n    i = 0\r\n    k = 0\r\n    spectr_left = []\r\n    spectr_right = []\r\n    attenuators = []\r\n    frame = ' '\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n\r\n        f_in = open(file_name, 'rb')\r\n        antenna = 0\r\n        while frame:\r\n\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [1:128]\r\n            for k in range(130):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n                elif k == 1:\r\n                    att_1 = frame_int & 0x3F\r\n                    att_2 = (frame_int & 0xFC0) >> 6\r\n                    att_3 = (frame_int & 0x3F000) >> 12\r\n                    noise_gen_on = (frame_int & 0x40000) >> 18\r\n                    antenna_before = antenna\r\n                    antenna = (frame_int & 0x80000) >> 19\r\n                    coupler = (frame_int & 0x100000) >> 20\r\n                    band = (frame_int & 0x8000000000000000) >> 63\r\n                    attenuators = [att_1, att_2, att_3]\r\n\r\n                    pass\r\n\r\n                else:\r\n                    spectr_val = (frame_int & 0x7FFFFFFFFFFFFF)\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    if pp_good / 256 < 0.78125:\r\n                        spectr_val = 2\r\n                    spectr_frame.append(spectr_val)\r\n                    pass\r\n\r\n            if antenna == 0 and (antenna_before - antenna == 0):\r\n                spectr_left.append(spectr_frame)\r\n            elif len(spectr_left) > 1 and ((antenna_before - antenna) != 0):\r\n                spectr_left.pop(-1)\r\n\r\n            if antenna == 1 and (antenna_before - antenna) == 0:\r\n                spectr_right.append(spectr_frame)\r\n            elif len(spectr_right) > 1 and ((antenna_before - antenna) != 0):\r\n                spectr_right.pop(-1)\r\n            print(i, frame_num, band)\r\n            i += 1\r\n\r\n        pass\r\n        n_right = len(spectr_right)\r\n        n_left = len(spectr_left)\r\n\r\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\r\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\r\n        # то необходима следующая процедура перестановки значений переменных\r\n        if n_right == 0 and antenna2_0 == 1:\r\n            spectr_right = spectr_left\r\n            spectr_left = []\r\n            n_right = len(spectr_right)\r\n            n_left = len(spectr_left)\r\n        # **********************************************************************************\r\n        if n_right > 1:\r\n            spectr_right.pop(-1)\r\n            n_frame_last = spectr_right[-1][0]\r\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n            if rest:\r\n                for k in range(rest):\r\n                    spectr_right.pop(-1)\r\n            print(n_frame_last, spectr_right[-1][0])\r\n        if n_left > 1:\r\n            spectr_left.pop(-1)\r\n            n_frame_last = spectr_left[-1][0]\r\n            rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n            if rest:\r\n                for k in range(rest):\r\n                    spectr_left.pop(-1)\r\n            print(n_frame_last, spectr_left[-1][0])\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n\r\n    if n_left > 1:\r\n        spectr1 = convert_to_matrix(spectr_left, spectr_left[-1][0] + 1, n_aver)\r\n    else:\r\n        spectr1 = []\r\n    if n_right > 1:\r\n        spectr2 = convert_to_matrix(spectr_right, spectr_right[-1][0] + 1, n_aver)\r\n    else:\r\n        spectr2 = []\r\n    spectrum_extr = pd.Series([spectr1, spectr2])\r\n    np.save(file_name0 + '_spectrum', spectrum_extr)\r\n    head = np.array([n_aver, 6, 8])\r\n    np.savetxt(file_name0 + '_head.txt', head)\r\n    return spectrum_extr, n_aver\r\n\r\n\r\ndef extract_whole_band():\r\n    file_name = Path(primary_data_file_path, current_primary_file + '.bin')\r\n    # *********** Если система работает с одной поляризацией ************\r\n    if not str(file_name).find('Ant2') == -1:\r\n        antenna2_0 = 1\r\n    else:\r\n        antenna2_0 = 0\r\n    # *******************************************************************\r\n    i = 0\r\n    spectrum_right_1 = []\r\n    spectrum_left_1 = []\r\n    spectrum_left_2 = []\r\n    spectrum_right_2 = []\r\n    attenuators = []\r\n    frame = ' '\r\n    frame_num_before = 0\r\n\r\n    try:\r\n        if os.path.isfile(file_name) == 1:\r\n            pass\r\n        else:\r\n            print('\\n \\t', file_name, ' not found!!!\\n')\r\n            return\r\n\r\n        f_in = open(file_name, 'rb')\r\n        antenna = 0\r\n        frame_num = 0\r\n        while frame:\r\n            spectr_frame = []\r\n            # Обработка кадра: выделение номера кадра, границ куртозиса, длины усреднения на ПЛИС\r\n            # и 128-ми значений спектра в список spectr_frame на позиции [2:129]\r\n            for k in range(130):\r\n                frame = f_in.read(8)\r\n                frame_int = int.from_bytes(frame, byteorder='little')\r\n                if k == 0:\r\n                    frame_num = frame_int & 0xFFFFFFF\r\n                    ind = 0\r\n\r\n                    # ********* Обработка сбоя приема \"нулевого\" байта с номером кадра *********\r\n                    # Из f_in байты будут\r\n                    # считываться до тех пор, пока число, прочитанное на месте в байте номера кадра, не\r\n                    # будет отличаться от предыдущего на величину меньше заданной. Если на протяжении 10\r\n                    # кадров такой байт не найдется (1300 байт), то обработка прерывается и выводятся\r\n                    # прочитанные до момента сбоя данные\r\n                    while abs(frame_num - frame_num_before) > 1000:\r\n                        frame = f_in.read(8)\r\n                        frame_int = int.from_bytes(frame, byteorder='little')\r\n                        frame_num = frame_int & 0xFFFFFFF\r\n                        ind += 1\r\n                        # delta_frame = frame_num - frame_num_before\r\n                        # print(ind, delta_frame)\r\n                        if ind > 1300:\r\n                            print('Прервывание обработки из-за сбоя определения номера кадра')\r\n                            break\r\n                    # ******************************************************************************\r\n\r\n                    # Выделение длины усреднения (количество усредняемых на ПЛИС отсчетов спектра = 2^n_aver)\r\n                    # Выделение промежутка для значения куртозиса = [2 - bound_left/64, 2 + bound_right/64])\r\n                    if i == 0:\r\n                        n_aver = (frame_int & 0x3F00000000) >> 32\r\n                        bound_left = (frame_int & 0x7FC000000000) >> (32 + 6)\r\n                        bound_right = (frame_int & 0xFF800000000000) >> (32 + 6 + 9)\r\n                    # Запись на первую позицию (с индексом 0) фрагмента спектра номера кадра frame_num\r\n                    spectr_frame.append(frame_num)\r\n                elif k == 1:\r\n                    att_1 = frame_int & 0x3F\r\n                    att_1 = int((63 - att_1) / 2)\r\n                    att_2 = (frame_int & 0xFC0) >> 6\r\n                    att_2 = int((63 - att_2) / 2)\r\n                    att_3 = (frame_int & 0x3F000) >> 12\r\n                    att_3 = int((63 - att_3) / 2)\r\n                    noise_gen_on = (frame_int & 0x40000) >> 18\r\n                    antenna_before = antenna\r\n                    antenna = (frame_int & 0x80000) >> 19\r\n                    if antenna == 1:\r\n                        pass\r\n                    coupler = (frame_int & 0x100000) >> 20\r\n                    band = (frame_int & 0x8000000000000000) >> 63\r\n                    attenuators = [att_1, att_2, att_3]\r\n                    if i == 10:\r\n                        att01 = att_1\r\n                        att02 = att_2\r\n                        att03 = att_3\r\n                    pass\r\n\r\n                else:\r\n                    spectrum_val = (frame_int & 0x7FFFFFFFFFFFFF) >> shift\r\n\r\n                    # Отбросили \"shift\" младших разрядов двоичного представления или 3 разряда десятичного\r\n                    # при \"shift=10\"\r\n                    # if band:\r\n                    #     spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_1]))\r\n                    # else:\r\n                    #     spectrum_val = int((spectrum_val * att_dict[att_3] * att_dict[att_2]))\r\n                    # if spectrum_val > 1000000000:\r\n                    #     spectrum_val = 1000000000\r\n                    pp_good = (frame_int & 0xFF80000000000000) >> 55\r\n                    if pp_good / 256 < pp_good_bound:\r\n                        spectrum_val = 2\r\n                    spectr_frame.append(spectrum_val)\r\n                    pass\r\n\r\n            if abs(frame_num_before - frame_num) > 1000:\r\n                print('Прервывание обработки из-за сбоя определения номера кадра')\r\n                break\r\n            if antenna == 0 and (antenna_before - antenna == 0):\r\n                if band:\r\n                    spectrum_left_2.append(spectr_frame)\r\n                else:\r\n                    spectrum_left_1.append(spectr_frame)\r\n            if len(spectrum_left_1) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_left_1.pop(-1)\r\n            if len(spectrum_left_2) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_left_2.pop(-1)\r\n\r\n            if antenna == 1 and (antenna_before - antenna) == 0:\r\n                if band:\r\n                    spectrum_right_2.append(spectr_frame)\r\n                else:\r\n                    spectrum_right_1.append(spectr_frame)\r\n            if len(spectrum_right_1) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_right_1.pop(-1)\r\n            if len(spectrum_right_2) > 1 and ((antenna_before - antenna) != 0):\r\n                spectrum_right_2.pop(-1)\r\n\r\n            print(i, frame_num, band, attenuators)\r\n            i += 1\r\n\r\n            frame_num_before = frame_num\r\n            # if att_1 == 31 & att_2 == 31 & att_3 == 31:\r\n            #     break\r\n        pass\r\n        n_right1 = len(spectrum_right_1)\r\n        n_left1 = len(spectrum_left_1)\r\n        n_right2 = len(spectrum_right_2)\r\n        n_left2 = len(spectrum_left_2)\r\n\r\n        # В случае, если при работе с одной поляризацией ('Ant1' или 'Ant2') в переменную\r\n        # antenna не записывается с какого входа берется сигнал (в любом случае antenna = 0),\r\n        # то необходима следующая процедура перестановки значений переменных\r\n        n_right = np.max([len(spectrum_right_1), len(spectrum_right_2)])\r\n        if n_right == 0 and antenna2_0 == 1:\r\n            spectrum_right_1 = spectrum_left_1\r\n            spectrum_left_1 = []\r\n            spectrum_right_2 = spectrum_left_2\r\n            spectrum_left_2 = []\r\n            n_right1 = len(spectrum_right_1)\r\n            n_left1 = len(spectrum_left_1)\r\n            n_right2 = len(spectrum_right_2)\r\n            n_left2 = len(spectrum_left_2)\r\n\r\n        # Приведение длины записи к величине кратной количеству частот\r\n        if n_right1 > 1:\r\n            spectrum_right_1 = cut_spectrum(spectrum_right_1, n_aver)\r\n            # spectrum_right_1 = np.array(spectrum_right_1, dtype=np.int32)\r\n            spectrum_right_1 = parts_to_numpy(spectrum_right_1, n_right1)\r\n        if n_left1 > 1:\r\n            spectrum_left_1 = cut_spectrum(spectrum_left_1, n_aver)\r\n            spectrum_left_1 = np.array(spectrum_left_1, dtype=np.int64)\r\n        if n_right2 > 1:\r\n            spectrum_right_2 = cut_spectrum(spectrum_right_2, n_aver)\r\n            # spectrum_right_2 = np.array(spectrum_right_2, dtype=np.int32)\r\n            spectrum_right_2 = parts_to_numpy(spectrum_right_2, n_right2)\r\n        if n_left2 > 1:\r\n            spectrum_left_2 = cut_spectrum(spectrum_left_2, n_aver)\r\n            spectrum_left_2 = np.array(spectrum_left_2, dtype=np.int64)\r\n    finally:\r\n        f_in.close()\r\n        pass\r\n    spectrum_extr = pd.Series([spectrum_left_1, spectrum_left_2, spectrum_right_1, spectrum_right_2])\r\n    # head = [n_aver, shift, bound_left, bound_right, att01, att02, att03]\r\n    band_size, polar, measure_kind = status_func(n_left1, n_left2, n_right1, n_right2)\r\n\r\n    head = {'date': date,\r\n            'measure_kind': measure_kind,    # Вид измерений: наблюдение Солнца, Луны, калибровка АЧХ\r\n            'band_size': band_size,  # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\r\n            # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\r\n            'polar': polar,  # Принимает значения поляризаций: 'both', 'left', 'right'\r\n            'cleaned': 'no',\r\n            'n_aver': n_aver,\r\n            'shift': shift,\r\n            'kurtosis': bound_left,\r\n            'good_bound': pp_good_bound,\r\n            'att1': att01,\r\n            'att2': att02,\r\n            'att3': att03,\r\n            'align_file_path': r'F:\\Fast_Acquisition\\Alignment\\Align_coeff.bin',\r\n            'align_coeff_pos': 5}\r\n    return save_spectrum(spectrum_extr, head)\r\n\r\n\r\ndef parts_to_numpy(list_arr, len_list):\r\n    \"\"\" Функция превращает список в массив numpy.\r\n    Разбивает файл на меньшие части и обрабатывает их поотдельности. По ходу завершинея обработки частей\r\n    происходит объединение обработанных частей.\"\"\"\r\n    n = int(len_list // 1e5)\r\n    k = int(len_list % 1e5)\r\n    numpy_arr = []\r\n    for i in range(n + 1):\r\n        if i == n:\r\n            auxiliary = list_arr[int(i * 1e5):int(i * 1e5 + k)]\r\n            auxiliary = np.array(auxiliary, dtype='int64')\r\n        else:\r\n            auxiliary = list_arr[int(i * 1e5):int((i + 1) * 1e5)]\r\n            auxiliary = np.array(auxiliary, dtype='int64')\r\n        l = np.size(numpy_arr)\r\n        if l:\r\n            numpy_arr = np.vstack([numpy_arr, auxiliary])\r\n        else:\r\n            numpy_arr = auxiliary\r\n\r\n    return numpy_arr\r\n\r\n\r\ndef status_func(n_left1, n_left2, n_right1, n_right2):\r\n\r\n    # Параметр 'whole' означает работу в диапазоне 1-3 ГГц,\r\n    # 'half_low' - диапазон 1-2, 'half_upper' - 2-3 ГГц\r\n    if (n_left1 > 1 and n_left2 > 1) or (n_right1 > 1 and n_right2 > 1):\r\n        band_size = 'whole'\r\n    if (n_left1 > 1 or n_right1 > 1) and (n_left2 <= 1 and n_right2 <= 1):\r\n        band_size = 'half_low'\r\n    if (n_left2 > 1 or n_right2 > 1) and (n_left1 <= 1 and n_right1 <= 1):\r\n        band_size = 'half_upper'\r\n\r\n    # polar Принамает значения поляризаций: 'both', 'left', 'right'\r\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 <= 1 or n_right2 <= 1):\r\n        polar = 'left'\r\n    if (n_left1 <= 1 or n_left2 <= 1) and (n_right1 > 1 or n_right2 > 1):\r\n        polar = 'right'\r\n    if (n_left1 > 1 or n_left2 > 1) and (n_right1 > 1 or n_right2 > 1):\r\n        polar = 'both'\r\n\r\n    # Определение вида измерений: наблюдение Солнца, Луны, калибровка АЧХ\r\n    measure_kind = ''\r\n    # file_name0 = str(Path(file_path_data, current_data_file))\r\n    if current_primary_dir.find('test') != -1:\r\n        # l = file_name0.find('test')\r\n        measure_kind = 'test'\r\n    if current_primary_dir.find('sun') != -1:\r\n        measure_kind = 'Sun'\r\n    if current_primary_dir.find('moon') != -1:\r\n        measure_kind = 'Moon'\r\n    if current_primary_dir.find('calibration') != -1 or current_primary_dir.find('calibr') != -1:\r\n        measure_kind = 'calibration'\r\n\r\n    return band_size, polar, measure_kind\r\n\r\n\r\ndef save_spectrum(spectrum_extr, head):\r\n    spectrum1 = spectrum_extr[0]\r\n    spectrum2 = spectrum_extr[1]\r\n    spectrum3 = spectrum_extr[2]\r\n    spectrum4 = spectrum_extr[3]\r\n    n_aver = head['n_aver']\r\n    band_size = head['band_size']\r\n    polar = head['polar']\r\n    measure_kind = head['measure_kind']\r\n    print(f'len_spectrum1 = {len(spectrum1)}, len_spectrum2 ={len(spectrum2)}, len_spectrum3 ={len(spectrum3)}, '\r\n          f'len_spectrum4 ={len(spectrum4)}')\r\n    if len(spectrum1) > 1:\r\n        spectrum1_low = convert_to_matrix(spectrum1, spectrum1[-1][0] + 1, n_aver)\r\n        pass\r\n    else:\r\n        spectrum1_low = []\r\n    if len(spectrum2) > 1:\r\n        spectrum1_high = convert_to_matrix(spectrum2, spectrum2[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum1_high = []\r\n    if len(spectrum3) > 1:\r\n        spectrum2_low = convert_to_matrix(spectrum3, spectrum3[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum2_low = []\r\n    if len(spectrum4) > 1:\r\n        spectrum2_high = convert_to_matrix(spectrum4, spectrum4[-1][0] + 1, n_aver)\r\n    else:\r\n        spectrum2_high = []\r\n    spectrum_whole = pd.Series([spectrum1_low, spectrum1_high, spectrum2_low, spectrum2_high])\r\n\r\n    # **** Создание папки для хранения конвертированных данных, если ее нет ****\r\n    if not os.path.isdir(Path(converted_data_file_path)):\r\n        os.mkdir(Path(converted_data_file_path))\r\n    # **************************************************************************\r\n\r\n    np.save(Path(converted_data_file_path, current_primary_file + '_spectrum'), spectrum_whole)\r\n    with open(Path(converted_data_file_path, current_primary_file + '_head.bin'), 'wb') as out:\r\n        pickle.dump(head, out)\r\n    jsn.dump(head, open(Path(converted_data_file_path, current_primary_file + '_head.txt'), \"w\"))\r\n\r\n    return print(f'Data in {current_primary_file} converted to numpy file and saved successfully')\r\n\r\n\r\ndef cut_spectrum(spectrum, n_aver):\r\n    spectrum.pop(-1)\r\n    n_frame_last = spectrum[-1][0]\r\n    rest = (n_frame_last + 1) % 2 ** (6 - n_aver)\r\n    if rest:\r\n        for k in range(rest):\r\n            spectrum.pop(-1)\r\n    print(n_frame_last, spectrum[-1][0])\r\n    return spectrum\r\n\r\n\r\ndef convert_to_matrix(S_total, counter, n_aver):\r\n    \"\"\"Функция принимает список списков S, который формируется в extract(file_name0) и превращает его в матрицу,\r\n    строки которой - спектры с разрешением 7.8125/(2**(6-n_aver)) МГц, а столбцы - зависимость значения\r\n    спектра на фиксированной частоте от времени. Разрешение по времени - 8192 мкс. Вместо пропущенных пакетов\r\n    вставляет значение 2\"\"\"\r\n    len_time = np.shape(S_total)[0]\r\n    S = [[int(2)] * 128 for i in range(counter)]\r\n    # S = [['NaN'] * 128 for i in range(counter)]\r\n    for s in S_total:\r\n        S[s[0]] = s[1:]\r\n    aver_param_loc = 2 ** (6 - n_aver)\r\n    n = 128 * aver_param_loc\r\n    print(len(S))\r\n    k = int(len(S) // n)\r\n    print(f' n = {n}, k = {k}')\r\n    parts = int(k // 100)\r\n    rest = int(k % 100)\r\n    s_agreed = []\r\n\r\n    for i in range(parts +1):\r\n        if i == parts:\r\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i * 100 + rest) * n)])\r\n            s_ar = np.reshape(s_auxiliary, (-1, n))\r\n        else:\r\n            s_auxiliary = np.array(S[int(i * 100 * n): int((i + 1) * 100 * n)])\r\n            s_ar = np.reshape(s_auxiliary, (-1, n))\r\n        l = np.size(s_agreed)\r\n        if l:\r\n            s_agreed = np.vstack([s_agreed, s_ar])\r\n        else:\r\n            s_agreed = s_ar\r\n\r\n    # s_agreed = np.array(S[0: k * n])\r\n    print(f'len_s_agreed = {len(s_agreed)}, shape = {np.shape(s_agreed)}')\r\n    # s_ar = np.reshape(s_agreed, (-1, n))\r\n    return s_agreed\r\n\r\n\r\ndef preparing_data():\r\n    \"\"\" Функция в зависимости от вида данных (полная полоса 1-3 ГГц, половинная полоса 1-2 или 2-3 ГГц,\r\n    с двумя поляризациями или одной) выдает данные для построения графиков\"\"\"\r\n\r\n    # Для полосы 1-3 ГГц и двух возможных поляризаций выдает по два спектра (1-2 и 2-3 ГГц) для каждой поляризации.\r\n    # Если поляризация не задействована, то соответствующие спектры - пустые. Спектр 1-2 ГГц - в обратном порядке\r\n    path1 = Path(converted_data_file_path, current_primary_file + '_spectrum.npy')\r\n    path2 = Path(converted_data_file_path, current_primary_file + '_left1.npy')\r\n    if not (os.path.isfile(path1) or\r\n            os.path.isfile(path2)):\r\n        if num_of_polar == 2 and band_size_init == 'whole':\r\n            extract_whole_band()\r\n        if num_of_polar == 2 and band_size_init == 'half':\r\n            extract_two_polar()\r\n    else:\r\n        print(f\"Data with path {str(Path(primary_data_file_path, current_primary_file))} is converted to numpy file\")\r\n\r\n    return print(f'Data in {current_primary_file} converted to numpy file successfully')\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n    start = datetime.now()\r\n\r\n    current_data_dir = '2022'\r\n    primary_data_dir = 'Primary_data'           # Каталог исходных данных (за определенный период, здесь - год)\r\n    converted_data_dir = 'Converted_data'       # Каталог для записи результатов конвертации данных и заголовков\r\n    data_treatment_dir = 'Data_treatment'       # Каталог для записи результатов обработки, рисунков\r\n\r\n    current_primary_dir = '2022_03_28moon'\r\n    current_primary_path = Path(primary_data_dir, current_primary_dir)\r\n    current_converted_dir = current_primary_dir + '_conv'\r\n    current_converted_path = Path(converted_data_dir, current_converted_dir)\r\n\r\n    current_primary_file = '2022-03-28_02+24'\r\n    primary_data_file_path, head_path = path_to_data(current_data_dir, current_primary_path)\r\n    converted_data_file_path, head_path = path_to_data(current_data_dir, current_converted_path)\r\n\r\n    align_file_name = 'Align_coeff.bin'         # Имя файла с текущими коэффициентами выравнивания АЧХ\r\n    folder_align_path = Path(head_path, 'Alignment')\r\n\r\n    date = current_primary_file[0:10]\r\n\r\n    # !!!! ******************************************* !!!!\r\n    # ****** Блок исходных параметров для обработки *******\r\n    band_size_init = 'whole'\r\n    num_of_polar = 2\r\n    pp_good_bound = 0.99\r\n    shift = 0\r\n    # band_size = 'whole'   Параметр 'whole' означает работу в диапазоне 1-3 ГГц, 'half' - диапазон 1-2 или 2-3 ГГц\r\n    # polar = 'both'        Принимает значения поляризаций: 'both', 'left', 'right'\r\n\r\n    att_val = [i * 0.5 for i in range(64)]\r\n    att_dict = {s: 10 ** (s / 10) for s in att_val}\r\n\r\n    preparing_data()\r\n\r\n    stop = datetime.now()\r\n    print(f'Process duration = {stop - start} sec')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Data_extraction/extract_from_flow.py b/Data_extraction/extract_from_flow.py
--- a/Data_extraction/extract_from_flow.py	(revision 40bd91099ec0babc7b0fc3b97654ef1eb2e753fd)
+++ b/Data_extraction/extract_from_flow.py	(date 1651237813548)
@@ -575,12 +575,12 @@
     converted_data_dir = 'Converted_data'       # Каталог для записи результатов конвертации данных и заголовков
     data_treatment_dir = 'Data_treatment'       # Каталог для записи результатов обработки, рисунков
 
-    current_primary_dir = '2022_03_28moon'
+    current_primary_dir = '2022_04_29sun'
     current_primary_path = Path(primary_data_dir, current_primary_dir)
     current_converted_dir = current_primary_dir + '_conv'
     current_converted_path = Path(converted_data_dir, current_converted_dir)
 
-    current_primary_file = '2022-03-28_02+24'
+    current_primary_file = '2022-04-29_05+12'
     primary_data_file_path, head_path = path_to_data(current_data_dir, current_primary_path)
     converted_data_file_path, head_path = path_to_data(current_data_dir, current_converted_path)
 
